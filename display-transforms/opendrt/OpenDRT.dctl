#line 2 // Fix line numbers in resolve/logs/rollinglog.txt

/* OpenDRT v1.0.0b42 -------------------------------------------------


  Written by Jed Smith
  https://github.com/jedypod/open-display-transform
  License: GPLv3
-------------------------------------------------*/



// Input settings
DEFINE_UI_PARAMS(in_gamut, Input Gamut, DCTLUI_COMBO_BOX, 15, {i_xyz, i_ap0, i_ap1, i_p3d65, i_rec2020, i_rec709, i_awg3, i_awg4, i_rwg, i_sgamut3, i_sgamut3cine, i_vgamut, i_bmdwg, i_egamut, i_egamut2, i_davinciwg}, {XYZ, ACES 2065-1, ACEScg, P3D65, Rec.2020, Rec.709, Arri Wide Gamut 3, Arri Wide Gamut 4, Red Wide Gamut RGB, Sony SGamut3, Sony SGamut3Cine, Panasonic V-Gamut, Blackmagic Wide Gamut, Filmlight E-Gamut, Filmlight E-Gamut2, DaVinci Wide Gamut})
DEFINE_UI_PARAMS(in_oetf, Input Transfer Function, DCTLUI_COMBO_BOX, 1, {ioetf_linear, ioetf_davinci_intermediate, ioetf_filmlight_tlog, ioetf_acescct, ioetf_arri_logc3, ioetf_arri_logc4, ioetf_panasonic_vlog, ioetf_sony_slog3, ioetf_fuji_flog}, {Linear, Davinci Intermediate, Filmlight T-Log, ACEScct, Arri LogC3, Arri LogC4, Panasonic V-Log, Sony S-Log3, Fuji F-Log2})

// Tonescale Parameters
DEFINE_UI_PARAMS(tn_Lp, Display Peak Luminance, DCTLUI_SLIDER_FLOAT, 100.0, 100.0, 1000.0, 0.0)

// Clamp
DEFINE_UI_PARAMS(_clamp, Clamp, DCTLUI_CHECK_BOX, 1)

// Creative White
DEFINE_UI_PARAMS(cwp, Creative White, DCTLUI_COMBO_BOX, 0, {_cwp0, _cwp1, _cwp2, _cwp3}, {D65, D60, D55, D50})
DEFINE_UI_PARAMS(cwp_rng, Creative White Range, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)




/*-------------------------------------------------------------------------------------- 
  Due to the limited nature of DCTL, I've made the choice to only expose the presets 
  and not the full parameter space. For those of you who are too curious for your own good
  and interested in experimenting...

!!! TO ENABLE STICKSHIFT MODE FOR CUSTOM LOOK CREATION:
    1. Un-Comment the lines in the section below. This enables all of the user parameters.
    2. Comment out the lines below that for the preset parameters (They won't do anything)

  Tip 1: If you are using a modern text editor like VSCode, 
    you can comment or un-comment multiple selected lines with Ctrl+/
  Tip 2: You can use the Nuke node to create a preset and click the "Show DCTL" button 
    to show code for the below with your custom parameter values. Or add your own presets
    in the LOOK PRESETS section around line 464.
---------------------------------------------------------------------------------------*/


// #define INIT_PARAMS

// DEFINE_UI_PARAMS(_tn_Lg, Grey Luminance, DCTLUI_SLIDER_FLOAT, 11.1, 4.0, 25.0, 0.0)
// DEFINE_UI_PARAMS(_tn_gb, Grey Boost, DCTLUI_SLIDER_FLOAT, 0.13, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_tn_con, Contrast, DCTLUI_SLIDER_FLOAT, 1.5, 1.0, 2.0, 0.0)
// DEFINE_UI_PARAMS(_tn_sh, Shoulder Clip, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_tn_toe, Toe, DCTLUI_SLIDER_FLOAT, 0.003, 0.0, 0.1, 0.0)
// DEFINE_UI_PARAMS(_tn_off, Offset, DCTLUI_SLIDER_FLOAT, 0.005, 0.0, 0.02, 0.0)
// DEFINE_UI_PARAMS(_tn_hcon_enable, High Contrast, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_tn_hcon, High Contrast, DCTLUI_SLIDER_FLOAT, -0.25, -1.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_tn_hcon_pv, High Contrast Pivot, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_tn_hcon_st, High Contrast Strength, DCTLUI_SLIDER_FLOAT, 4.0, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_tn_mcon_enable, Mid Contrast, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_tn_mcon, Mid Contrast, DCTLUI_SLIDER_FLOAT, 0.8, 0.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_tn_mcon_w, Mid Contrast Width, DCTLUI_SLIDER_FLOAT, 0.7, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_tn_mcon_pc, Mid Contrast Per-Channel, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_rs_sa, Render Space Strength, DCTLUI_SLIDER_FLOAT, 0.35, 0.0, 0.6, 0.0)
// DEFINE_UI_PARAMS(_rs_rw, Render Space Red Weight, DCTLUI_SLIDER_FLOAT, 0.2, 0.0, 0.8, 0.0)
// DEFINE_UI_PARAMS(_rs_bw, Render Space Blue Weight, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 0.8, 0.0)
// DEFINE_UI_PARAMS(_pt_r, Purity Compress R, DCTLUI_SLIDER_FLOAT, 0.1, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_pt_g, Purity Compress G, DCTLUI_SLIDER_FLOAT, 1.5, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_pt_b, Purity Compress B, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_pt_rng_low, Purity Range Low, DCTLUI_SLIDER_FLOAT, 0.3, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_pt_rng_high, Purity Range High, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_pt_hdr, Purity HDR, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_pt_softclip, Softclip , DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_ptm_enable, Mid Purity, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_ptm_low, Mid Purity Low, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_ptm_low_st, Mid Purity Low Strength, DCTLUI_SLIDER_FLOAT, 0.5, 0.1, 1.0, 0.0)
// DEFINE_UI_PARAMS(_ptm_high, Mid Purity High, DCTLUI_SLIDER_FLOAT, -0.5, -1.0, 0.0, 0.0)
// DEFINE_UI_PARAMS(_ptm_high_st, Mid Purity High Strength, DCTLUI_SLIDER_FLOAT, 1.0, 0.1, 1.0, 0.0)
// DEFINE_UI_PARAMS(_vl_enable, Value, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_vl_r, Value R, DCTLUI_SLIDER_FLOAT, -0.3, -0.5, 0.0, 0.0)
// DEFINE_UI_PARAMS(_vl_g, Value G, DCTLUI_SLIDER_FLOAT, -0.15, -0.5, 0.0, 0.0)
// DEFINE_UI_PARAMS(_vl_b, Value B, DCTLUI_SLIDER_FLOAT, -0.05, -0.5, 0.0, 0.0)
// DEFINE_UI_PARAMS(_vl_rng, Value Range, DCTLUI_SLIDER_FLOAT, 0.9, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rgb_enable, Hueshift RGB, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_hs_r, Hueshift R, DCTLUI_SLIDER_FLOAT, 0.3, 0.0, 0.5, 0.0)
// DEFINE_UI_PARAMS(_hs_g, Hueshift G, DCTLUI_SLIDER_FLOAT, 0.25, 0.0, 0.5, 0.0)
// DEFINE_UI_PARAMS(_hs_b, Hueshift B, DCTLUI_SLIDER_FLOAT, 0.3, 0.0, 0.5, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_r, Hueshift Range R, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_g, Hueshift Range G, DCTLUI_SLIDER_FLOAT, 3.0, 0.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_b, Hueshift Range B, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hs_cmy_enable, Hueshift CMY, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_hs_c, Hueshift C, DCTLUI_SLIDER_FLOAT, 0.2, 0.0, 0.5, 0.0)
// DEFINE_UI_PARAMS(_hs_m, Hueshift M, DCTLUI_SLIDER_FLOAT, 0.2, 0.0, 0.5, 0.0)
// DEFINE_UI_PARAMS(_hs_y, Hueshift Y, DCTLUI_SLIDER_FLOAT, 0.2, 0.0, 0.5, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_c, Hueshift Range C, DCTLUI_SLIDER_FLOAT, 1.5, -3.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_m, Hueshift Range M, DCTLUI_SLIDER_FLOAT, -1.5, -3.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_y, Hueshift Range Y, DCTLUI_SLIDER_FLOAT, 1.5, -3.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hc_enable, Hue Contrast, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_hc_r0, Hue Contrast R Low, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hc_r1, Hue Contrast R High, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hc_g0, Hue Contrast G Low, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hc_g1, Hue Contrast G High, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hc_b0, Hue Contrast B Low, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hc_b1, Hue Contrast B High, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hc_rng, Hue Contrast Range, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)

// DEFINE_UI_PARAMS(_display_gamut, Display Gamut, DCTLUI_COMBO_BOX, 0, {Rec709, P3D65, Rec2020}, {Rec.709, P3-D65, Rec.2020 (P3 Limited)})
// DEFINE_UI_PARAMS(_eotf, Display EOTF, DCTLUI_COMBO_BOX, 2, {eotf0, eotf1, eotf2, eotf3, eotf4, eotf5}, {Linear, 2.2 Power sRGB Display, 2.4 Power Rec.1886, 2.6 Power DCI, ST 2084 PQ, HLG})


/*---------------------------------------------------------------------------------------
!!! TO ENABLE STICKSHIFT MODE FOR CUSTOM LOOK CREATION: COMMENT OUT the preset parameters below.
---------------------------------------------------------------------------------------*/

// Preset Parameters
DEFINE_UI_PARAMS(look_preset, Look Preset, DCTLUI_COMBO_BOX, 1, {look0, look1, look2}, {Base, Default, Colorful})
DEFINE_UI_PARAMS(tonescale_preset, Tonescale Preset, DCTLUI_COMBO_BOX, 0, {tsprst0, tsprst1, tsprst2, tsprst3, tsprst4, tsprst5, tsprst6}, {Use Look Preset, High-Contrast, Low-Contrast, ACES-1.x, ACES-2.0, High-Contrast 2, Low-Contrast 2})
DEFINE_UI_PARAMS(display_encoding_preset, Display Encoding Preset, DCTLUI_COMBO_BOX, 0, {rec1886, srgb, p3display, rec2100pq, rec2100hlg, dolbypq}, {Rec.1886 - 2.4 Power / Rec.709, sRGB Display - 2.2 Power / Rec.709, P3 Display - 2.2 Power / P3-D65, Rec.2100 - PQ / Rec.2020 (P3 Limited), Rec.2100 - HLG / Rec.2020 (P3 Limited), Dolby - PQ / P3-D65})

/*---------------------------------------------------------------------------------------*/





// Gamut Conversion Matrices
#define matrix_ap0_to_xyz make_float3x3(make_float3(0.93863094875f, -0.00574192055f, 0.017566898852f), make_float3(0.338093594922f, 0.727213902811f, -0.065307497733f), make_float3(0.000723121511f, 0.000818441849f, 1.0875161874f))
#define matrix_ap1_to_xyz make_float3x3(make_float3(0.652418717672f, 0.127179925538f, 0.170857283842f), make_float3(0.268064059194f, 0.672464478993f, 0.059471461813f), make_float3(-0.00546992851f, 0.005182799977f, 1.08934487929f))
#define matrix_rec709_to_xyz make_float3x3(make_float3(0.412390917540f, 0.357584357262f, 0.180480793118f), make_float3(0.212639078498f, 0.715168714523f, 0.072192311287f), make_float3(0.019330825657f, 0.119194783270f, 0.950532138348f))
#define matrix_p3d65_to_xyz make_float3x3(make_float3(0.486571133137f, 0.265667706728f, 0.198217317462f), make_float3(0.228974640369f, 0.691738605499f, 0.079286918044f), make_float3(0.0f, 0.045113388449, 1.043944478035f))
#define matrix_xyz_to_p3d65 make_float3x3(make_float3(2.49349691194f, -0.931383617919f, -0.402710784451f), make_float3(-0.829488969562f, 1.76266406032f, 0.023624685842f), make_float3(0.035845830244f, -0.076172389268f, 0.956884524008f))
#define matrix_rec2020_to_xyz make_float3x3(make_float3(0.636958122253f, 0.144616916776f, 0.168880969286f), make_float3(0.262700229883f, 0.677998125553f, 0.059301715344f), make_float3(0.0f, 0.028072696179, 1.060985088348f))
#define matrix_arriwg3_to_xyz make_float3x3(make_float3(0.638007619284f, 0.214703856337f, 0.097744451431f), make_float3(0.291953779f, 0.823841041511f, -0.11579482051f), make_float3(0.002798279032f, -0.067034235689f, 1.15329370742f))
#define matrix_arriwg4_to_xyz make_float3x3(make_float3(0.704858320407f, 0.12976029517f, 0.115837311474f), make_float3(0.254524176404f, 0.781477732712f, -0.036001909116f), make_float3(0.0f, 0.0f, 1.08905775076f))
#define matrix_redwg_to_xyz make_float3x3(make_float3(0.735275208950f, 0.068609409034f, 0.146571278572f), make_float3(0.286694079638f, 0.842979073524f, -0.129673242569f), make_float3(-0.079680845141f, -0.347343206406, 1.516081929207f))
#define matrix_sonysgamut3_to_xyz make_float3x3(make_float3(0.706482713192f, 0.128801049791f, 0.115172164069f), make_float3(0.270979670813f, 0.786606411221f, -0.057586082034f), make_float3(-0.009677845386f, 0.004600037493f, 1.09413555865f))
#define matrix_sonysgamut3cine_to_xyz make_float3x3(make_float3(0.599083920758f, 0.248925516115f, 0.102446490178f), make_float3(0.215075820116f, 0.885068501744f, -0.100144321859f), make_float3(-0.032065849545f, -0.027658390679f, 1.14878199098f))
#define matrix_vgamut_to_xyz make_float3x3(make_float3(0.679644469878f, 0.15221141244f, 0.118600044733), make_float3(0.26068555009f, 0.77489446333f, -0.03558001342), make_float3(-0.009310198218f, -0.004612467044f, 1.10298041602))
#define matrix_bmdwg_to_xyz make_float3x3(make_float3(0.606538414955f, 0.220412746072f, 0.123504832387f), make_float3(0.267992943525f, 0.832748472691f, -0.100741356611f), make_float3(-0.029442556202f, -0.086612440646, 1.205112814903f))
#define matrix_egamut_to_xyz make_float3x3(make_float3(0.705396831036f, 0.164041340351f, 0.081017754972f), make_float3(0.280130714178f, 0.820206701756f, -0.100337378681f), make_float3(-0.103781513870f, -0.072907261550, 1.265746593475f))
#define matrix_egamut2_to_xyz make_float3x3(make_float3(0.736477700184f, 0.130739651087f, 0.083238575781f), make_float3(0.275069984406f, 0.828017790216f, -0.103087774621f), make_float3(-0.124225154248f, -0.087159767391f, 1.3004426724f))
#define matrix_davinciwg_to_xyz make_float3x3(make_float3(0.700622320175f, 0.148774802685f, 0.101058728993f), make_float3(0.274118483067f, 0.873631775379f, -0.147750422359f), make_float3(-0.098962903023f, -0.137895315886, 1.325916051865f))

// Display gamuts with Normalized adaptation matrices for other creative whitepoints (CAT02)
#define matrix_p3_to_p3_d50 make_float3x3(make_float3(0.9287127388f, 0.06578032793f, 0.005506708345f), make_float3(-0.002887159176f, 0.8640709228f, 4.3593718e-05f), make_float3(-0.001009551548f, -0.01073503317f, 0.6672692039f))
#define matrix_p3_to_p3_d55 make_float3x3(make_float3(0.9559790976f, 0.0403850003f, 0.003639287409f), make_float3(-0.001771929896f, 0.9163058305f, 3.3300759e-05f), make_float3(-0.000674760809f, -0.0072466358f, 0.7831189153f))
#define matrix_p3_to_p3_d60 make_float3x3(make_float3(0.979832881f, 0.01836378979f, 0.001803284786f), make_float3(-0.000805359793f, 0.9618000331f, 1.8876121e-05f), make_float3(-0.000338382322f, -0.003671835795f, 0.894139105f))
#define matrix_p3_to_rec709_d50 make_float3x3(make_float3(1.103807322f, -0.1103425121f, 0.006531676079f), make_float3(-0.04079386701f, 0.8704694227f, -0.000180522628f), make_float3(-0.01854055914f, -0.07857582481f, 0.7105498861f))
#define matrix_p3_to_rec709_d55 make_float3x3(make_float3(1.149327514f, -0.1536910745f, 0.004366526746f), make_float3(-0.0412590771f, 0.9351717477f, -0.000116126221f), make_float3(-0.01900949528f, -0.07928282823f, 0.8437884317f))
#define matrix_p3_to_rec709_d60 make_float3x3(make_float3(1.189986856f, -0.192168414f, 0.002185496045f), make_float3(-0.04168263635f, 0.9927757018f, -5.5660878e-05f), make_float3(-0.01937995127f, -0.07933006919f, 0.9734397041f))
#define matrix_p3_to_rec709_d65 make_float3x3(make_float3(1.224940181f, -0.2249402404f, 0.0f), make_float3(-0.04205697775f, 1.042057037f, -1.4901e-08f), make_float3(-0.01963755488f, -0.07863604277f, 1.098273635f))
#define matrix_p3_to_rec2020 make_float3x3(make_float3(0.7538330344f, 0.1985973691f, 0.04756959659f), make_float3(0.04574384897f, 0.9417772198f, 0.01247893122f), make_float3(-0.001210340355f, 0.0176017173f, 0.9836086231f))


/* Math helper functions ----------------------------*/

__CONSTANT__ float SQRT3 = 1.73205080756887729353f;

typedef struct {
  float3 x, y, z;
} float3x3;

// Helper function to create a float3x3
__DEVICE__ float3x3 make_float3x3(float3 a, float3 b, float3 c) {
  float3x3 d;
  d.x = a, d.y = b, d.z = c;
  return d;
}

// Return identity 3x3 matrix
__DEVICE__ float3x3 identity() {
  return make_float3x3(make_float3(1.0f, 0.0f, 0.0f), make_float3(0.0f, 1.0f, 0.0f), make_float3(0.0f, 0.0f, 1.0f));
}

// Multiply 3x3 matrix m and float3 vector v
__DEVICE__ float3 vdot(float3x3 m, float3 v) {
  return make_float3(m.x.x*v.x + m.x.y*v.y + m.x.z*v.z, m.y.x*v.x + m.y.y*v.y + m.y.z*v.z, m.z.x*v.x + m.z.y*v.y + m.z.z*v.z);
}

// Safe division of float a by float b
__DEVICE__ float sdivf(float a, float b) {
  if (b == 0.0f) return 0.0f;
  else return a/b;
}

// Safe division of float3 a by float b
__DEVICE__ float3 sdivf3f(float3 a, float b) {
  return make_float3(sdivf(a.x, b), sdivf(a.y, b), sdivf(a.z, b));
}

// Safe element-wise division of float3 a by float3 b
__DEVICE__ float3 sdivf3f3(float3 a, float3 b) {
  return make_float3(sdivf(a.x, b.x), sdivf(a.y, b.y), sdivf(a.z, b.z));
}

// Safe power function raising float a to power float b
__DEVICE__ float spowf(float a, float b) {
  if (a <= 0.0f) return a;
  else return _powf(a, b);
}

// Safe power function raising float3 a to power float b
__DEVICE__ float3 spowf3(float3 a, float b) {
  return make_float3(spowf(a.x, b), spowf(a.y, b), spowf(a.z, b));
}

// Return the hypot or vector length of float3 a
__DEVICE__ float hypotf3(float3 a) { return _sqrtf(a.x*a.x + a.y*a.y + a.z*a.z); }

// Return the min of float3 a
__DEVICE__ float fmaxf3(float3 a) { return _fmaxf(a.x, _fmaxf(a.y, a.z)); }

// Return the max of float3 a
__DEVICE__ float fminf3(float3 a) { return _fminf(a.x, _fminf(a.y, a.z)); }

// Clamp float3 a to max value mx
__DEVICE__ float3 clampmaxf3(float3 a, float mx) { return make_float3(_fminf(a.x, mx), _fminf(a.y, mx), _fminf(a.z, mx)); }

// Clamp float3 a to min value mn
__DEVICE__ float3 clampminf3(float3 a, float mn) { return make_float3(_fmaxf(a.x, mn), _fmaxf(a.y, mn), _fmaxf(a.z, mn)); }

// Clamp float3 a to min value mn and max value mx
__DEVICE__ float clampf(float a, float mn, float mx) { return _fminf(_fmaxf(a, mn), mx); }
__DEVICE__ float3 clampf3(float3 a, float mn, float mx) { return make_float3(clampf(a.x, mn, mx), clampf(a.y, mn, mx), clampf(a.z, mn, mx)); }


/* OETF Linearization Transfer Functions ---------------------------------------- */

__DEVICE__ float oetf_davinci_intermediate(float x) {
    return x <= 0.02740668f ? x/10.44426855f : _exp2f(x/0.07329248f - 7.0f) - 0.0075f;
}
__DEVICE__ float oetf_filmlight_tlog(float x) {
  return x < 0.075f ? (x-0.075f)/16.184376489665897f : _expf((x - 0.5520126568606655f)/0.09232902596577353f) - 0.0057048244042473785f;
}
__DEVICE__ float oetf_acescct(float x) {
  return x <= 0.155251141552511f ? (x - 0.0729055341958355f)/10.5402377416545f : _exp2f(x*17.52f - 9.72f);
}
__DEVICE__ float oetf_arri_logc3(float x) {
  return x < 5.367655f*0.010591f + 0.092809f ? (x - 0.092809f)/5.367655f : (_exp10f((x - 0.385537f)/0.247190f) - 0.052272f)/5.555556f;
}
__DEVICE__ float oetf_arri_logc4(float x) {
  return x < -0.7774983977293537f ? x*0.3033266726886969f - 0.7774983977293537f : (_exp2f(14.0f*(x - 0.09286412512218964f)/0.9071358748778103f + 6.0f) - 64.0f)/2231.8263090676883f;
}
__DEVICE__ float oetf_panasonic_vlog(float x) {
  return x < 0.181f ? (x - 0.125f)/5.6f : _exp10f((x - 0.598206f)/0.241514f) - 0.00873f;
}
__DEVICE__ float oetf_sony_slog3(float x) {
  return x < 171.2102946929f/1023.0f ? (x*1023.0f - 95.0f)*0.01125f/(171.2102946929f - 95.0f) : (_exp10f(((x*1023.0f - 420.0f)/261.5f))*(0.18f + 0.01f) - 0.01f);
}
__DEVICE__ float oetf_fujifilm_flog2(float x) {
  return x < 0.100686685370811f ? (x - 0.092864f)/8.799461f : (_exp10f(((x - 0.384316f)/0.245281f))/5.555556f - 0.064829f/5.555556f);
}


__DEVICE__ float3 linearize(float3 rgb, int tf) {
  if (tf==0) { // Linear
    return rgb;
  } else if (tf==1) { // Davinci Intermediate
    rgb.x = oetf_davinci_intermediate(rgb.x);
    rgb.y = oetf_davinci_intermediate(rgb.y);
    rgb.z = oetf_davinci_intermediate(rgb.z);
  } else if (tf==2) { // Filmlight T-Log
    rgb.x = oetf_filmlight_tlog(rgb.x);
    rgb.y = oetf_filmlight_tlog(rgb.y);
    rgb.z = oetf_filmlight_tlog(rgb.z);
  } else if (tf==3) { // ACEScct
    rgb.x = oetf_acescct(rgb.x);
    rgb.y = oetf_acescct(rgb.y);
    rgb.z = oetf_acescct(rgb.z);
  } else if (tf==4) { // Arri LogC3
    rgb.x = oetf_arri_logc3(rgb.x);
    rgb.y = oetf_arri_logc3(rgb.y);
    rgb.z = oetf_arri_logc3(rgb.z);
  } else if (tf==5) { // Arri LogC4
    rgb.x = oetf_arri_logc4(rgb.x);
    rgb.y = oetf_arri_logc4(rgb.y);
    rgb.z = oetf_arri_logc4(rgb.z);
  } else if (tf==6) { // Panasonic V-Log
    rgb.x = oetf_panasonic_vlog(rgb.x);
    rgb.y = oetf_panasonic_vlog(rgb.y);
    rgb.z = oetf_panasonic_vlog(rgb.z);
  } else if (tf==7) { // Sony S-Log3
    rgb.x = oetf_sony_slog3(rgb.x);
    rgb.y = oetf_sony_slog3(rgb.y);
    rgb.z = oetf_sony_slog3(rgb.z);
  } else if (tf==8) { // Fuji F-Log2
    rgb.x = oetf_fujifilm_flog2(rgb.x);
    rgb.y = oetf_fujifilm_flog2(rgb.y);
    rgb.z = oetf_fujifilm_flog2(rgb.z);
  }
  return rgb;
}



/* EOTF Transfer Functions ---------------------------------------- */

__DEVICE__ float3 eotf_hlg(float3 rgb, int inverse) {
  /* Apply the HLG Forward or Inverse EOTF for 1000 nits. 
      ITU-R Rec BT.2100-2 https://www.itu.int/rec/R-REC-BT.2100 
      ITU-R Rep BT.2390-8: https://www.itu.int/pub/R-REP-BT.2390
  */
  
  if (inverse == 1) {
    float Yd = 0.2627f*rgb.x + 0.6780f*rgb.y + 0.0593f*rgb.z;
    rgb = rgb*spowf(Yd, (1.0f - 1.2f)/1.2f);
    rgb.x = rgb.x <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.x) : 0.17883277f*_logf(12.0f*rgb.x - 0.28466892f) + 0.55991073f;
    rgb.y = rgb.y <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.y) : 0.17883277f*_logf(12.0f*rgb.y - 0.28466892f) + 0.55991073f;
    rgb.z = rgb.z <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.z) : 0.17883277f*_logf(12.0f*rgb.z - 0.28466892f) + 0.55991073f;
  } else {
    rgb.x = rgb.x <= 0.5f ? rgb.x*rgb.x/3.0f : (_expf((rgb.x - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    rgb.y = rgb.y <= 0.5f ? rgb.y*rgb.y/3.0f : (_expf((rgb.y - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    rgb.z = rgb.z <= 0.5f ? rgb.z*rgb.z/3.0f : (_expf((rgb.z - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    float Ys = 0.2627f*rgb.x + 0.6780f*rgb.y + 0.0593f*rgb.z;
    rgb = rgb*spowf(Ys, 1.2f - 1.0f);
  }
  return rgb;
}


__DEVICE__ float3 eotf_pq(float3 rgb, int inverse) {
  /* Apply the ST-2084 PQ Forward or Inverse EOTF
      ITU-R Rec BT.2100-2 https://www.itu.int/rec/R-REC-BT.2100
      ITU-R Rep BT.2390-9 https://www.itu.int/pub/R-REP-BT.2390
      Note: in the spec there is a normalization for peak display luminance. 
      For this function we assume the input is already normalized such that 1.0 = 10,000 nits
  */
  
  const float m1 = 2610.0f/16384.0f;
  const float m2 = 2523.0f/32.0f;
  const float c1 = 107.0f/128.0f;
  const float c2 = 2413.0f/128.0f;
  const float c3 = 2392.0f/128.0f;

  if (inverse == 1) {
    rgb = spowf3(rgb, m1);
    rgb = spowf3((c1 + c2*rgb)/(1.0f + c3*rgb), m2);
  } else {
    rgb = spowf3(rgb, 1.0f/m2);
    rgb = spowf3((rgb - c1)/(c2 - c3*rgb), 1.0f/m1);
  }
  return rgb;
}


/* Functions for OpenDRT ---------------------------------------- */

__DEVICE__ float compress_powerp(float x, float p) {
  // Unconstrained variable slope compression function. https://www.desmos.com/calculator/flquiy0s0y
  return x < 0.0f ? x : x*spowf(1.0f + spowf(x, 1.0f/p), -p);
}

__DEVICE__ float compress_hyperbolic_power(float x, float s, float p) {
  // Simple hyperbolic compression function https://www.desmos.com/calculator/ofwtcmzc3w
  return spowf(x/(x + s), p);
}

__DEVICE__ float compress_toe_quadratic(float x, float toe, int inv) {
  // Quadratic toe compress function https://www.desmos.com/calculator/skk8ahmnws
  if (toe == 0.0f) return x;
  if (inv == 0) {
    return spowf(x, 2.0f)/(x + toe);
  } else {
    return (x + _sqrtf(x*(4.0f*toe + x)))/2.0f;
  }
}

__DEVICE__ float compress_toe_cubic(float x, float m, float w, int inv) {
  // https://www.desmos.com/calculator/ubgteikoke
  if (m==1.0f) return x;
  float x2 = x*x;
  if (inv == 0) {
    return x*(x2 + m*w)/(x2 + w);
  } else {
    float p0 = x2 - 3.0f*m*w;
    float p1 = 2.0f*x2 + 27.0f*w - 9.0f*m*w;
    float p2 = _powf(_sqrtf(x2*p1*p1 - 4*p0*p0*p0)/2.0f + x*p1/2.0f, 1.0f/3.0f);
    return p0/(3.0f*p2) + p2/3.0f + x/3.0f;
  }
}

__DEVICE__ float sigmoid_cubic_power(float x, float s, float p) {
  // Simple cubic sigmoid: https://www.desmos.com/calculator/hzgib42en6
  if (x < 0.0f || x > 1.0f) return 1.0f;
  x = 1.0f - _powf(1.0f - x, 1.0f/p);
  return 1.0f + s*(1.0f - 3.0f*x*x + 2.0f*x*x*x);
}

__DEVICE__ float contrast_high(float x, float p, float pv, float pv_lx, int inv) {
  // High exposure adjustment with linear extension
  // https://www.desmos.com/calculator/etjgwyrgad
  const float x0 = 0.18f*_powf(2.0f, pv);
  if (x < x0 || p == 1.0f) return x;

  const float o = x0 - x0/p;
  const float s0 = _powf(x0, 1.0f - p)/p;
  const float x1 = x0*_powf(2.0f, pv_lx);
  const float k1 = p*s0*_powf(x1, p)/x1;
  const float y1 = s0*_powf(x1, p) + o;
  if (inv==1)
    return x > y1 ? (x - y1)/k1 + x1 : _powf((x - o)/s0, 1.0f/p);
  else
    return x > x1 ? k1*(x - x1) + y1 : s0*_powf(x, p) + o;
}


__DEVICE__ float3 narrow_ha(float3 c) {
  /* Take "Wide" hue angles, for example RGB_Ratios - min(RGB_Ratios) or 1.0 - RGB_Ratios
      and "Narrow" them using a tent window extraction to get RGB or CMY,
      Then unpremult by min(RGB_Ratios) and apply smoothing to avoid mach bands and kinks.
      For smoothing we use the "compress_to_quadratic" function.
  */
  c = make_float3(_fmaxf(0.0f, c.x - (c.y + c.z)), _fmaxf(0.0f, c.y - (c.x + c.z)), _fmaxf(0.0f, c.z - (c.x + c.y)));
  // Smooth
  c.x = compress_toe_quadratic(c.x, 0.1f, 0);
  c.y = compress_toe_quadratic(c.y, 0.1f, 0);
  c.z = compress_toe_quadratic(c.z, 0.1f, 0);
  return c;
}






__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
  float3 rgb = make_float3(p_R, p_G, p_B);

  /*****************************************************
    Parameter Setup
    --------------------------------------------------*/
  
  // Init look preset variables
  int tn_hcon_enable, tn_mcon_enable, ptm_enable, vl_enable, hs_rgb_enable, hs_cmy_enable, hc_enable, display_gamut, eotf;
  float tn_Lg, tn_gb, tn_con, tn_sh, tn_toe, tn_off, tn_hcon, tn_hcon_pv, tn_hcon_st, tn_mcon, tn_mcon_w, tn_mcon_pc, rs_sa, rs_rw, rs_bw, pt_r, pt_g, pt_b, pt_rng_low, pt_rng_high, pt_hdr, pt_softclip, ptm_low, ptm_low_st, ptm_high, ptm_high_st, vl_r, vl_g, vl_b, vl_rng, hs_r, hs_g, hs_b, hs_rng_r, hs_rng_g, hs_rng_b, hs_c, hs_m, hs_y, hs_rng_c, hs_rng_m, hs_rng_y, hc_r0, hc_r1, hc_g0, hc_g1, hc_b0, hc_b1, hc_rng;


  #ifdef INIT_PARAMS  // Set all parameters to the user-controllable ones instead of presets if INIT_PARAMS defined by user.
    
  tn_Lg=_tn_Lg, tn_gb=_tn_gb, tn_con=_tn_con, tn_sh=_tn_sh, tn_toe=_tn_toe, tn_off=_tn_off, tn_hcon_enable=_tn_hcon_enable, tn_hcon=_tn_hcon, tn_hcon_pv=_tn_hcon_pv, tn_hcon_st=_tn_hcon_st, tn_mcon_enable=_tn_mcon_enable, tn_mcon=_tn_mcon, tn_mcon_w=_tn_mcon_w, tn_mcon_pc=_tn_mcon_pc, rs_sa=_rs_sa, rs_rw=_rs_rw, rs_bw=_rs_bw, pt_r=_pt_r, pt_g=_pt_g, pt_b=_pt_b, pt_rng_low=_pt_rng_low, pt_rng_high=_pt_rng_high, pt_hdr=_pt_hdr, pt_softclip=_pt_softclip, ptm_enable=_ptm_enable, ptm_low=_ptm_low, ptm_low_st=_ptm_low_st, ptm_high=_ptm_high, ptm_high_st=_ptm_high_st, vl_enable=_vl_enable, vl_r=_vl_r, vl_g=_vl_g, vl_b=_vl_b, vl_rng=_vl_rng, hs_rgb_enable=_hs_rgb_enable, hs_r=_hs_r, hs_g=_hs_g, hs_b=_hs_b, hs_rng_r=_hs_rng_r, hs_rng_g=_hs_rng_g, hs_rng_b=_hs_rng_b, hs_cmy_enable=_hs_cmy_enable, hs_c=_hs_c, hs_m=_hs_m, hs_y=_hs_y, hs_rng_c=_hs_rng_c, hs_rng_m=_hs_rng_m, hs_rng_y=_hs_rng_y, hc_enable=_hc_enable, hc_r0=_hc_r0, hc_r1=_hc_r1, hc_g0=_hc_g0, hc_g1=_hc_g1, hc_b0=_hc_b0, hc_b1=_hc_b1, hc_rng=_hc_rng, display_gamut=_display_gamut, eotf=_eotf;

  #else // Otherwise, drive everything based on the preset combo box parameters.
  
  /*----------- LOOK PRESETS -----------------*/
  // Look presets to go after 
  if (look_preset==0) { // Base
    tn_Lg = 11.1f, tn_gb = 0.13f, tn_con = 1.5f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.003f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 0, tn_mcon = 0.0f, tn_mcon_w = 0.7f, tn_mcon_pc = 1.0f, rs_sa = 0.35f, rs_rw = 0.2f, rs_bw = 0.5f, pt_r = 0.1f, pt_g = 1.5f, pt_b = 1.0f, pt_rng_low = 0.3f, pt_rng_high = 1.0f, pt_hdr = 0.5f, pt_softclip = 1, ptm_enable = 0, ptm_low = 0.0f, ptm_low_st = 0.5f, ptm_high = 0.0f, ptm_high_st = 1.0f, vl_enable = 0, vl_r = 0.0f, vl_g = 0.0f, vl_b = 0.0f, vl_rng = 1.0f, hs_rgb_enable = 0, hs_r = 0.0f, hs_g = 0.0f, hs_b = 0.0f, hs_rng_r = 1.0f, hs_rng_g = 1.0f, hs_rng_b = 1.0f, hs_cmy_enable = 0, hs_c = 0.0f, hs_m = 0.0f, hs_y = 0.0f, hs_rng_c = 0.0f, hs_rng_m = 0.0f, hs_rng_y = 0.0f, hc_enable = 0, hc_r0 = 0.0f, hc_r1 = 0.0f, hc_g0 = 0.0f, hc_g1 = 0.0f, hc_b0 = 0.0f, hc_b1 = 0.0f, hc_rng = 0.5f;
  }
  else if (look_preset==1) { // Default
    tn_Lg = 11.1f, tn_gb = 0.13f, tn_con = 1.5f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.005f, tn_hcon_enable = 1, tn_hcon = -0.25f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 1, tn_mcon = 0.8f, tn_mcon_w = 0.7f, tn_mcon_pc = 1.0f, rs_sa = 0.35f, rs_rw = 0.2f, rs_bw = 0.5f, pt_r = 0.2f, pt_g = 1.5f, pt_b = 1.0f, pt_rng_low = 0.3f, pt_rng_high = 1.0f, pt_hdr = 0.5f, pt_softclip = 1, ptm_enable = 1, ptm_low = 0.5f, ptm_low_st = 0.5f, ptm_high = -0.8f, ptm_high_st = 0.66f, vl_enable = 1, vl_r = -0.3f, vl_g = -0.15f, vl_b = -0.05f, vl_rng = 0.8f, hs_rgb_enable = 1, hs_r = 0.3f, hs_g = 0.3f, hs_b = 0.3f, hs_rng_r = 1.0f, hs_rng_g = 1.0f, hs_rng_b = 1.0f, hs_cmy_enable = 1, hs_c = 0.2f, hs_m = 0.2f, hs_y = 0.2f, hs_rng_c = 1.0f, hs_rng_m = 0.0f, hs_rng_y = 0.0f, hc_enable = 1, hc_r0 = 0.5f, hc_r1 = 0.5f, hc_g0 = 0.0f, hc_g1 = 0.5f, hc_b0 = 0.0f, hc_b1 = 0.0f, hc_rng = 0.5f;
  }
  else if (look_preset==2) { // Colorful
    tn_Lg = 11.1f, tn_gb = 0.13f, tn_con = 1.3f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.003f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 1, tn_mcon = 0.6f, tn_mcon_w = 0.7f, tn_mcon_pc = 1.0f, rs_sa = 0.35f, rs_rw = 0.2f, rs_bw = 0.5f, pt_r = 0.5f, pt_g = 2.0f, pt_b = 1.0f, pt_rng_low = 0.3f, pt_rng_high = 1.0f, pt_hdr = 0.5f, pt_softclip = 1, ptm_enable = 1, ptm_low = 0.9f, ptm_low_st = 1.0f, ptm_high = -0.9f, ptm_high_st = 0.66f, vl_enable = 1, vl_r = -0.3f, vl_g = -0.15f, vl_b = -0.05f, vl_rng = 0.5f, hs_rgb_enable = 1, hs_r = 0.3f, hs_g = 0.3f, hs_b = 0.3f, hs_rng_r = 1.0f, hs_rng_g = 1.0f, hs_rng_b = 1.0f, hs_cmy_enable = 1, hs_c = 0.2f, hs_m = 0.2f, hs_y = 0.1f, hs_rng_c = 1.5f, hs_rng_m = -1.5f, hs_rng_y = 1.5f, hc_enable = 1, hc_r0 = 0.5f, hc_r1 = 0.5f, hc_g0 = 0.0f, hc_g1 = 0.5f, hc_b0 = 0.0f, hc_b1 = 0.0f, hc_rng = 0.5f;
  }

  /*----------- TONESCALE PRESETS -----------------*/
  if (tonescale_preset==0) { // Do nothing and use tonescale settings from the look preset
  }
  if (tonescale_preset==1) { // High-Contrast
    tn_Lg = 11.1f, tn_con = 1.5f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.005f, tn_hcon_enable = 1, tn_hcon = -0.25f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 1, tn_mcon = 0.8f, tn_mcon_w = 0.7f, tn_mcon_pc = 1.0f;
  }
  else if (tonescale_preset==2) { // Low-Contrast
    tn_Lg = 11.1f, tn_con = 1.5f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.003f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 0, tn_mcon = 0.0f, tn_mcon_w = 0.7f, tn_mcon_pc = 1.0f;
  }
  else if (tonescale_preset==3) { // ACES-1.x
    tn_Lg = 10.0f, tn_con = 1.0f, tn_sh = 0.245f, tn_toe = 0.02f, tn_off = 0.0f, tn_hcon_enable = 1, tn_hcon = 0.55f, tn_hcon_pv = 0.0f, tn_hcon_st = 2.0f, tn_mcon_enable = 1, tn_mcon = 1.13f, tn_mcon_w = 1.0f, tn_mcon_pc = 1.0f;
  }
  else if (tonescale_preset==4) { // ACES-2.0
    tn_Lg = 10.0f, tn_con = 1.15f, tn_sh = 0.5f, tn_toe = 0.04f, tn_off = 0.0f, tn_hcon_enable = 0, tn_hcon = 1.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 1.0f, tn_mcon_enable = 0, tn_mcon = 1.0f, tn_mcon_w = 0.6f, tn_mcon_pc = 1.0f;
  }
  else if (tonescale_preset==5) { // High-Contrast 2
    tn_Lg = 6.0f, tn_con = 1.5f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.01f, tn_hcon_enable = 1, tn_hcon = 0.25f, tn_hcon_pv = 0.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 1, tn_mcon = 1.0f, tn_mcon_w = 1.0f, tn_mcon_pc = 1.0f;
  }
  else if (tonescale_preset==6) { // Low-Contrast 2
    tn_Lg = 11.1f, tn_con = 1.0f, tn_sh = 0.5f, tn_toe = 0.1f, tn_off = 0.01f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 0.0f, tn_hcon_st = 2.0f, tn_mcon_enable = 1, tn_mcon = 2.5f, tn_mcon_w = 0.16f, tn_mcon_pc = 1.0f;
  }

  /*----------- DISPLAY ENCODING PRESETS -----------------*/
  if (display_encoding_preset==0) { // Rec.1886
    display_gamut = 0;
    eotf = 2;
  }
  else if (display_encoding_preset==1) { // sRGB Display
    display_gamut = 0;
    eotf = 1;
  }
  else if (display_encoding_preset==2) { // Display P3
    display_gamut = 1;
    eotf = 1;
  }
  else if (display_encoding_preset==3) { // Rec.2100 PQ
    display_gamut = 2;
    eotf = 4;
  }
  else if (display_encoding_preset==4) { // Rec.2100 HLG
    display_gamut = 2;
    eotf = 5;
  }
  else if (display_encoding_preset==4) { // Dolby PQ
    display_gamut = 1;
    eotf = 4;
  }

  #endif



  float3x3 in_to_xyz;
  if (in_gamut==0) in_to_xyz = identity();
  else if (in_gamut==1) in_to_xyz = matrix_ap0_to_xyz;
  else if (in_gamut==2) in_to_xyz = matrix_ap1_to_xyz;
  else if (in_gamut==3) in_to_xyz = matrix_p3d65_to_xyz;
  else if (in_gamut==4) in_to_xyz = matrix_rec2020_to_xyz;
  else if (in_gamut==5) in_to_xyz = matrix_rec709_to_xyz;
  else if (in_gamut==6) in_to_xyz = matrix_arriwg3_to_xyz;
  else if (in_gamut==7) in_to_xyz = matrix_arriwg4_to_xyz;
  else if (in_gamut==8) in_to_xyz = matrix_redwg_to_xyz;
  else if (in_gamut==9) in_to_xyz = matrix_sonysgamut3_to_xyz;
  else if (in_gamut==10) in_to_xyz = matrix_sonysgamut3cine_to_xyz;
  else if (in_gamut==11) in_to_xyz = matrix_vgamut_to_xyz;
  else if (in_gamut==12) in_to_xyz = matrix_bmdwg_to_xyz;
  else if (in_gamut==13) in_to_xyz = matrix_egamut_to_xyz;
  else if (in_gamut==14) in_to_xyz = matrix_egamut2_to_xyz;
  else if (in_gamut==15) in_to_xyz = matrix_davinciwg_to_xyz;



  // Linearize if a non-linear input oetf / transfer function is selected
  if (in_oetf==1) {
    rgb.x = oetf_davinci_intermediate(rgb.x);
    rgb.y = oetf_davinci_intermediate(rgb.y);
    rgb.z = oetf_davinci_intermediate(rgb.z);
  } else if (in_oetf==2) {
    rgb.x = oetf_filmlight_tlog(rgb.x);
    rgb.y = oetf_filmlight_tlog(rgb.y);
    rgb.z = oetf_filmlight_tlog(rgb.z);
  } else if (in_oetf==3) {
    rgb.x = oetf_arri_logc3(rgb.x);
    rgb.y = oetf_arri_logc3(rgb.y);
    rgb.z = oetf_arri_logc3(rgb.z);
  } else if (in_oetf==4) {
    rgb.x = oetf_arri_logc4(rgb.x);
    rgb.y = oetf_arri_logc4(rgb.y);
    rgb.z = oetf_arri_logc4(rgb.z);
  } else if (in_oetf==5) {
    rgb.x = oetf_panasonic_vlog(rgb.x);
    rgb.y = oetf_panasonic_vlog(rgb.y);
    rgb.z = oetf_panasonic_vlog(rgb.z);
  } else if (in_oetf==6) {
    rgb.x = oetf_sony_slog3(rgb.x);
    rgb.y = oetf_sony_slog3(rgb.y);
    rgb.z = oetf_sony_slog3(rgb.z);
  } else if (in_oetf==7) {
    rgb.x = oetf_fujifilm_flog2(rgb.x);
    rgb.y = oetf_fujifilm_flog2(rgb.y);
    rgb.z = oetf_fujifilm_flog2(rgb.z);
  }



  /***************************************************
    Tonescale Constraint Calculations
    https://www.desmos.com/calculator/1c4fhzy3bw

    These could be pre-calculated but there is no way to do this in DCTL.
    Anything that is const should be precalculated and not run per-pixel
    --------------------------------------------------*/
  const float ts_x1 = _powf(2.0f, 6.0f*tn_sh + 4.0f);
  const float ts_y1 = tn_Lp/100.0f;
  const float ts_x0 = 0.18f + tn_off;
  const float ts_y0 = tn_Lg/100.0f*(1.0f + tn_gb*_log2f(ts_y1));
  const float ts_s0 = compress_toe_quadratic(ts_y0, tn_toe, 1);
  const float ts_s10 = ts_x0*(_powf(ts_s0, -1.0f/tn_con) - 1.0f);
  const float ts_m1 = ts_y1/_powf(ts_x1/(ts_x1 + ts_s10), tn_con);
  const float ts_m2 = compress_toe_quadratic(ts_m1, tn_toe, 1);
  const float ts_s = ts_x0*(_powf(ts_s0/ts_m2, -1.0f/tn_con) - 1.0f);
  const float ts_dsc = eotf==4 ? 0.01 : eotf==5 ? 0.1 : 100.0f/tn_Lp;

  // Lerp from pt_cmp at 100 nits to pt_cmp_hdr at 1000 nits
  const float pt_cmp_Lf = pt_hdr*_fminf(1.0f, (tn_Lp - 100.0f)/900.0f);
  // Approximate scene-linear scale at Lp=100 nits
  const float s_Lp100 = ts_x0*(_powf((tn_Lg/100.0f), -1.0f/tn_con) - 1.0f);
  const float ts_s1 = ts_s*pt_cmp_Lf + s_Lp100*(1.0f - pt_cmp_Lf);
  

  // Convert from input gamut into P3-D65
  rgb = vdot(in_to_xyz, rgb);
  rgb = vdot(matrix_xyz_to_p3d65, rgb);


  // Rendering Space: "Desaturate" to control scale of the color volume in the rgb ratios.
  // Controlled by rs_sa (saturation) and red and blue weights (rs_rw and rs_bw)
  float3 rs_w = make_float3(rs_rw, 1.0f - rs_rw - rs_bw, rs_bw);
  float sat_L = rgb.x*rs_w.x + rgb.y*rs_w.y + rgb.z*rs_w.z;
  rgb = sat_L*rs_sa + rgb*(1.0f - rs_sa);
  

  // Offset
  rgb += tn_off;


  /***************************************************
    Midtone Contrast Module
  --------------------------------------------------*/
  if (tn_mcon_enable) {
    float mcon_m = _powf(2.0f, -tn_mcon);
    float mcon_w = tn_mcon_w/4.0f;
    mcon_w *= mcon_w;

    // Normalize for ts_x0 intersection constraint
    const float mcon_cnst_sc = compress_toe_cubic(ts_x0, mcon_m, mcon_w, 1)/ts_x0;
    rgb *= mcon_cnst_sc;
    
    // Scale for ratio-preserving midtone contrast
    float mcon_nm = hypotf3(clampminf3(rgb, 0.0f))/SQRT3;
    float mcon_sc = (mcon_nm*mcon_nm + mcon_m*mcon_w)/(mcon_nm*mcon_nm + mcon_w);
    
    if (tn_mcon_pc > 0.0f) {
      // Mix between ratio-preserving and per-channel by blending based on distance from achromatic

      // Apply per-channel midtone contrast
      float3 mcon_rgb = rgb;
      mcon_rgb.x = compress_toe_cubic(rgb.x, mcon_m, mcon_w, 0);
      mcon_rgb.y = compress_toe_cubic(rgb.y, mcon_m, mcon_w, 0);
      mcon_rgb.z = compress_toe_cubic(rgb.z, mcon_m, mcon_w, 0);

      // Always use some amount of ratio-preserving method towards gamut boundary
      float mcon_mx = fmaxf3(rgb);
      float mcon_mn = fminf3(rgb);
      float mcon_ch = clampf(1.0f - sdivf(mcon_mn, mcon_mx), 0.0, 1.0);
      mcon_ch = _powf(mcon_ch, 4.0f*tn_mcon_pc);
      rgb = mcon_sc*rgb*mcon_ch + mcon_rgb*(1.0f - mcon_ch);
    } 
    else { // Just use ratio-preserving
      rgb = mcon_sc*rgb;
    }
  }


  // Tonescale Norm
  float tsn = hypotf3(clampminf3(rgb, 0.0f))/SQRT3;

  // Purity Compression Norm
  float ts_pt = _sqrtf(_fmaxf(0.0f, rgb.x*rgb.x*pt_r + rgb.y*rgb.y*pt_g + rgb.z*rgb.z*pt_b));

  // RGB Ratios
  rgb = sdivf3f(clampminf3(rgb, -2.0f), tsn);

  // Apply High Contrast
  if (tn_hcon_enable) {
    float hcon_p = _powf(2.0f, tn_hcon);
    tsn = contrast_high(tsn, hcon_p, tn_hcon_pv, tn_hcon_st, 0);
    ts_pt = contrast_high(ts_pt, hcon_p, tn_hcon_pv, tn_hcon_st, 0);
  }

  // Apply tonescale
  tsn = compress_hyperbolic_power(tsn, ts_s, tn_con);
  ts_pt = compress_hyperbolic_power(ts_pt, ts_s1, tn_con);
  

  // RGB CMY Hue Angles
  float mn = _fmaxf(0.0f, fminf3(rgb));
  float ach_d = 1.0f - mn; // achromatic distance
  float3 ha_rgb = rgb - mn;
  ha_rgb = sdivf3f(ha_rgb, ach_d); // Unpremult
  ha_rgb = narrow_ha(ha_rgb);
  
  float3 ha_cmy = clampminf3(1.0f - rgb, 0.0f);
  ha_cmy = sdivf3f(ha_cmy, ach_d); // Unpremult
  ha_cmy = narrow_ha(ha_cmy);
  // Smooth ach_d, normalized so 1.0 doesn't change
  ach_d = (1.0f + 0.1f)*compress_toe_quadratic(ach_d, 0.1f, 0);
  
  // Premult by smoothed ach_d
  ha_rgb *= ach_d;
  ha_cmy *= ach_d;
  

  // Purity Compression Range: https://www.desmos.com/calculator/8ynarg1uxk
  float ts_pt_cmp = _powf(1.0f - _powf(ts_pt, 1.0f/pt_rng_low), pt_rng_high);



  /***************************************************
    Mid-Range Purity 
      This boosts mid-range purity on the low end
      and reduces mid-range purity on the high end
  --------------------------------------------------*/
  float ptm_sc = 1.0f;
  if (ptm_enable) {
    // We use a different definition of saturation / chroma / achromatic distance for this adjustment 
    // to avoid mach bands: a simple opponent colorspace

    float opp_cy = rgb.x - rgb.z;
    float opp_gm = rgb.y - (rgb.x + rgb.z)/2.0f;
    float opp_ach_d = _sqrtf(_fmaxf(0.0f, opp_cy*opp_cy + opp_gm*opp_gm))/1.6f; // hypot normalized so roughly equivalent to ach_d
    
    // Mid Purity Low
    ptm_sc = sigmoid_cubic_power(opp_ach_d, ptm_low*(1.0f - ts_pt), ptm_low_st);
  
    // Mid Purity High
    ptm_sc *= sigmoid_cubic_power(opp_ach_d, ptm_high*ts_pt, ptm_high_st);
  }



  /***************************************************
    Hue Contrast
  --------------------------------------------------*/
  if (hc_enable) {
    float hc_ts = _powf(1.0f - ts_pt, _powf(4.0f, 1.0f - hc_rng));
    // Limit high purity on bottom end and low purity on top end by ach_d. 
    // This helps reduce artifacts and over-saturation.
    float hc_c = (1.0f - ach_d)*hc_ts + ach_d*(1.0f - hc_ts);
    float3 hc_rgb = make_float3(ha_rgb.x*hc_c, ha_rgb.y*hc_c, ha_rgb.z*hc_c/2.0f);

    // Bias contrast based on tonescale using Lift/Mult: https://www.desmos.com/calculator/gzbgov62hl
    float3 hc_f = make_float3(
      hc_r1 - hc_ts*(hc_r0 + hc_r1),
      hc_g1 - hc_ts*(hc_g0 + hc_g1),
      hc_b1 - hc_ts*(hc_b0 + hc_b1));
    hc_f *= hc_rgb;

    hc_f = make_float3(
      hc_f.y + hc_f.z + 1.0f,
      hc_f.x + hc_f.z + 1.0f, 
      hc_f.x + hc_f.y + 1.0f);
    rgb *= hc_f;
  }



  /***************************************************
    Hue Shift
  --------------------------------------------------*/
  
  // Hue Shift RGB by purity compress tonescale, shifting more as intensity increases
  if (hs_rgb_enable) {
    float3 hs_rgb = make_float3(
      _powf(1.0f - ts_pt_cmp, _powf(2.0f, -hs_rng_r)),
      _powf(1.0f - ts_pt_cmp, _powf(2.0f, -hs_rng_g)),
      _powf(1.0f - ts_pt_cmp, _powf(2.0f, -hs_rng_b)));
    // hs_rgb *= spowf(ach_d, 0.15f); // smooth transition into achromatic
    hs_rgb *= ha_rgb;
    float3 hsf = make_float3(hs_rgb.x*hs_r, hs_rgb.y*-hs_g, hs_rgb.z*-hs_b);
    hsf = make_float3(hsf.z - hsf.y, hsf.x - hsf.z, hsf.y - hsf.x);
    rgb += hsf;
  }

  // Hue Shift CMY by tonescale, shifting less as intensity increases
  if (hs_cmy_enable) {
    float3 hs_cmy = make_float3(
      _powf(1.0f - ts_pt, _powf(2.0f, -hs_rng_c)),
      _powf(1.0f - ts_pt, _powf(2.0f, -hs_rng_m)),
      _powf(1.0f - ts_pt, _powf(2.0f, -hs_rng_y)));
    hs_cmy *= ha_cmy;
    
    // Limit shift by sqrt of ach_d to help smoothness at achromatic and reduce effect in mid-purity range
    hs_cmy *= spowf(ach_d, 0.5f);
    float3 hsf = make_float3(hs_cmy.x*-hs_c, hs_cmy.y*hs_m, hs_cmy.z*hs_y);
    hsf = make_float3(hsf.z - hsf.y, hsf.x - hsf.z, hsf.y - hsf.x);
    rgb += hsf;
  }
  


  /***************************************************
    Value
  --------------------------------------------------*/
  if (vl_enable) {
    float vl_f = (vl_r*ha_rgb.x + 1.0f)*(vl_g*ha_rgb.y + 1.0f)*(vl_b*ha_rgb.z + 1.0f);
    float vl_lim = spowf(ts_pt, 1.0f - vl_rng);
    vl_f = vl_f*vl_lim + 1.0f - vl_lim;
    vl_f = _fmaxf(0.0f, _fminf(2.0f, vl_f)); // protect for shadow grain
    rgb *= vl_f;
  }



  // Purity Compression + mid purity
  ts_pt_cmp *= ptm_sc;
  rgb = rgb*ts_pt_cmp + 1.0f - ts_pt_cmp;

  // Inverse Rendering Space
  sat_L = rgb.x*rs_w.x + rgb.y*rs_w.y + rgb.z*rs_w.z;
  rgb = (sat_L*rs_sa - rgb)/(rs_sa - 1.0f);

  // Convert to final display gamut
  float3 cwp_rgb = rgb;
  if (display_gamut==0) {
    if (cwp==1) cwp_rgb = vdot(matrix_p3_to_rec709_d60, rgb);
    if (cwp==2) cwp_rgb = vdot(matrix_p3_to_rec709_d55, rgb);
    if (cwp==3) cwp_rgb = vdot(matrix_p3_to_rec709_d50, rgb);
    rgb = vdot(matrix_p3_to_rec709_d65, rgb);
    if (cwp==0) cwp_rgb = rgb;
  }
  else if (display_gamut==1) {
    if (cwp==1) cwp_rgb = vdot(matrix_p3_to_p3_d60, rgb);
    if (cwp==2) cwp_rgb = vdot(matrix_p3_to_p3_d55, rgb);
    if (cwp==3) cwp_rgb = vdot(matrix_p3_to_p3_d50, rgb);
  }

  // Mix between Creative Whitepoint and D65 by tsn
  float cwp_f = _powf(tsn, 1.0f - cwp_rng);
  rgb = cwp_rgb*cwp_f + rgb*(1.0f - cwp_f);

  // Purity Softclip
  if (pt_softclip) {
    float sum0 = rgb.x + rgb.y + rgb.z;
    rgb = 1.0f - rgb;
    rgb.x = compress_powerp(rgb.x, 0.03f);
    rgb.y = compress_powerp(rgb.y, 0.05f);
    rgb.z = compress_powerp(rgb.z, 0.02f);
    rgb = 1.0f - rgb;
    rgb *= sdivf(sum0, rgb.x + rgb.y + rgb.z);
  }

  // Final tonescale adjustments
  tsn *= ts_m2; // scale for inverse toe
  tsn = compress_toe_quadratic(tsn, tn_toe, 0);
  tsn *= ts_dsc; // scale for display encoding
  
  // Return from RGB ratios
  rgb *= tsn;

  // Clamp
  if (_clamp) rgb = clampf3(rgb, 0.0f, 1.0f);

  // Rec.2020 (P3 Limited)
  if (display_gamut==2) {
    rgb = clampminf3(rgb, 0.0f);
    rgb = vdot(matrix_p3_to_rec2020, rgb);
  }

  // Apply inverse Display EOTF
  float eotf_p = 2.0f + eotf * 0.2f;
  if ((eotf > 0) && (eotf < 4)) {
    rgb = spowf3(rgb, 1.0f/eotf_p);
  } else if (eotf == 4) {
    rgb = eotf_pq(rgb, 1);
  } else if (eotf == 5) {
    rgb = eotf_hlg(rgb, 1);
  }
  
  return rgb;
}