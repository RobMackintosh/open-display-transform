#line 2 // Fix line numbers in resolve/logs/rollinglog.txt

/* OpenDRT v1.0.0b38 -------------------------------------------------

# Release Notes

## OpenDRT v1.0.0
This version of OpenDRT adds significant updates refinements and new features, with the overall goal of improving the default image rendering capabilities so that additional look operations upstream are not necessarily required. Instead of being an image formation proposal where significant upstream look development work is **required**, the aim is to include a minimal set of look development tools that can work towards creating a more "finished" image, out of the box. Significant rewrites and improvements have also been made to improve gradient smoothness and overall image appearance (see below).

### New Features
- Improve **Tonescale**
  - Add **Midtone Contrast** to the tonescale functions. This operation allows creative control over "contrast" in the midtones and shadows, and enables opendrt to form a more finished image out of the box, if desired. It can be applied per-channel or in an RGB ratio preserving manner.
  - Add **High Contrast** to the tonescale functions. This operation allows creative control over the slope of the shoulder in the tonescale, allowing higher "highlight" contrast like ACES 1.x, or more "filmic" low-slope shoulder tonescale looks.
  - Add **Offset** control. It turns out that adding a small positive offset is a very important creative component of image appearance, and to omit this would be a mis-step.
  - Revise tonescale system math. 
    - Previously OpenDRT used a tonescale system similar to [the one Daniele Siragusano posted on acescentral](https://community.acescentral.com/t/output-transform-tone-scale/3498/224), but slightly modified to allow exact intersection constraints for middle grey and peak display. It accomplished this by applying the display linear output scale before the power function. The end result was pretty much identical due to the intersection constraints, but the downside was that it was difficult to access the 0-1 range pre-output y scale, which is necessary for many look operations like the high end purity compression. Basically you had to do all parts of the tonescale and then un-scale it for the purity compression and other operations. This always bothered me. 
    - For this new version I went back and figured out a new way to solve the constraints when applying output y scale after the power function. This model differs from Daniele's formulation. It prioritizes an exact solve for middle grey, and uses an approximate solve for peak display. Peak display intersection is much less critical to accurately map since small variations are not visible in the image and will suffer from lack of precision in the final integer display encoding. More details available here: https://www.desmos.com/calculator/1c4fhzy3bw
- Refine **Purity Compression**
  - Previously the purity compression behavior was tied to the "rendering space" weights. To allow more control, purity compression is now driven by a separate non-normalized weighted euclidean norm, which allows better creative control over the purity compression behavior per hue angle. These parameters are exposed as Purity Compression R G B controls. 
  - Purity Compression Range is the new name for the previously exposed Purity Compress Low slider. 
  - Add Purity HDR control. This allows creative control over the amount of purity compression as Peak Luminance is increased. At 0, the purity compression will not change as display peak luminance goes up. At 1, purity compression is reduced as peak luminance increases. The previous model for top end purity compression did not work well with the transition from SDR to HDR.
- Add **Mid Purity** adjustments
  - Mid-range purity turns out to be incredibly important for image formation, especially some amount of compression in purity at the top end in the cyan-yellow regions. This helps improve the horrible pasty pastel image appearance in image formation approaches like ACES 2, TCAM, and Arri Reveal. To this end I've added a look module to accomplish this as well as to _boost_ mid-range purity at the bottom end.
- Expose **Value** parameters. This module is a mix between a creative look adjustment and a necessary image rendering adjustment. Basically it scales down the vector, increasing with distance from achromatic. This operation reduces disruptions in gradients of narrow spectra lights sources, and can also be used creatively to achieve more "dense" or "filmic" color appearance.
- Add **Hue Shift** preferential look modification module. Older versions of OpenDRT had something similar, but it was limited to only adjusting the apparent hue of "highlights" affected by the top end purity copmression. This new module offers more flexibility, and is re-engineered to work better as a creative control. It affects more the hue angles near the primaries, and has a creative "range" parameter which allows control over the intensity range that is affected. For example if you boost "range r", reds in the shadows will shift more orange.
- Add **Hue Focus** preferential look modification module. This operation affects mid range purity and also hue angle. For example if Hue Focus Low R is increased, mid-range purity of reds is increased, and there is a hue distortion at the bottom end towards the red primary from both the yellow and magenta side. And conversely, if Hue Focus High R is decreased, mid-range purity at the top end is decreased, and the hue angles distort towards the yellow and magenta secondary. This module allows a creatively controllable way to dial in some of the nice look aspects of per-channel without being creatively shackled to the tonescale curve.
- Add **Creative White** adjustment. This sets the color of the peak luminance in the final image. D65 is the default, but the color can be made warmer all the way down to D50 to achieve a filmic look with warmer highlights. Additionally a **Creative White Range** slider was added to control how much to affect midtones and shadows. At 1.0, this operation is simply a CAT matrix to the desired whitepoint. At 0.0, it is mixed by the tonescale curve.
- Expose **Softclip** parameter, and allow it to be disabled. This is a final "gamut compress" style operation that improves smooth rendering of colorful gradients, though at the cost of a slight reduction in saturation at the gamut boundary.
- Add a selection of **Look Presets**
  - **Base**: Just the base image formation without any preferential hue distortion or contrast boost, though includes a base level of the "Value" adjustment to create smooth gradients. A good starting point for stronger more involved look development.
  - **Default**: Balanced, "neutral" image reproduction with natural colors and enough saturation and preferential hue distortions to create a nice looking picture, without being so strong of a look as to preclude it as a base for further look development.
  - **Filmish**: A very basic "film look", with stronger color crosstalk / preferential hue distortion, higher color contrast. Coule work well if a warmer D50 whitepoint were used as well.
- Add a selection of **Tonescale Presets**
  - High Contrast: The default setting. Enough contrast to maybe be called a "finished" image, but also could be a good base to build on.
  - Low Contrast: A low contrast starting point. Requires further contrast to be added in grading in order to achieve a "finished" image.
  - ACES 1.x: An emulation of the ACES 1.x tonescale curve. One deviation is mapping 0.0 to 0.0 through the tonescale curve, rather than mapping +0.02 to 0.0... because ain't nobody got time for that nonsense.
  - ACES 2.0: An exact match of the ACES 2.0 tonescale curve, in case you are a fan of a low contrast curve with extremely crushed shadows.
  - High Contrast 2: A more dark and "cinematic" high contrast tonescale curve. Maps middle grey to 6 nits in a 100 nit container for creative effect.
  - Low Contrast 2: A variation of Low Contrast which sets the overall slope a bit lower, but adds a positive offset and a bit more deep shadow contrast. A modern interpretion of the K1S1 legacy.


### Improvements
- Re-engineer mid-range purity low and high to be more robust.
- Re-engineer density method to have RGBCMY controls, and to avoid folding.
- Reduce density of blue. Combined with the new Hue Shift design, this improves presentation of saturated blue colors.

### Bug Fixes
- The Nuke implementation's HLG output had incorrect HDR scaling for peak luminances other than 1000 nits.


# DCTL Notes
Due to the limited nature of DCTL, I've made the choice to only expose the presets and not the full parameter space. For those of you who are more technically minded and interested in experimenting, you can access the full parameter set with the following steps:
1. Un-comment lines 66 to 128 below to expose the DCTL parameters.
2. Set the Look preset and Tonescale preset to "Custom (Check DCTL)"


  Written by Jed Smith
  https://github.com/jedypod/open-display-transform
  License: GPLv3
-------------------------------------------------*/


#define INIT_PARAMS // Blank fallback in case custom parameters are commented out


/* Un-Comment below this line to enable custom look creation
---------------------------------------------------------------------------------------*/

// DEFINE_UI_PARAMS(_tn_Lg, Grey Luminance, DCTLUI_SLIDER_FLOAT, 11.1, 4.0, 25.0, 0.0)
// DEFINE_UI_PARAMS(_tn_gb, Grey Boost, DCTLUI_SLIDER_FLOAT, 0.13, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_tn_con, Contrast, DCTLUI_SLIDER_FLOAT, 1.4, 1.0, 2.0, 0.0)
// DEFINE_UI_PARAMS(_tn_sh, Shoulder Clip, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_tn_toe, Toe, DCTLUI_SLIDER_FLOAT, 0.001, 0.0, 0.04, 0.0)
// DEFINE_UI_PARAMS(_tn_off, Offset, DCTLUI_SLIDER_FLOAT, 0.002, 0.0, 0.02, 0.0)
// DEFINE_UI_PARAMS(_tn_hcon_enable, High Contrast, DCTLUI_CHECK_BOX, 0)
// DEFINE_UI_PARAMS(_tn_hcon, High Contrast, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_tn_hcon_pv, HCon Pivot, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_tn_hcon_st, HCon Strength, DCTLUI_SLIDER_FLOAT, 4.0, 0.0, 4.0, 0.0)
// DEFINE_UI_PARAMS(_tn_mcon_enable, Mid Contrast, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_tn_mcon, Mid Contrast, DCTLUI_SLIDER_FLOAT, 0.8, 0.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_tn_mcon_w, MCon Width, DCTLUI_SLIDER_FLOAT, 0.7, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_tn_mcon_pc, MCon Per-Channel, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_pt_r, Purity Compress R, DCTLUI_SLIDER_FLOAT, 0.4, 0.05, 2.0, 0.0)
// DEFINE_UI_PARAMS(_pt_g, Purity Compress G, DCTLUI_SLIDER_FLOAT, 0.3, 0.05, 2.0, 0.0)
// DEFINE_UI_PARAMS(_pt_b, Purity Compress B, DCTLUI_SLIDER_FLOAT, 1.3, 0.05, 2.0, 0.0)
// DEFINE_UI_PARAMS(_pt_rng, Purity Compress Range, DCTLUI_SLIDER_FLOAT, 0.25, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_pt_hdr, Purity HDR, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_pt_softclip, Softclip , DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_ptm_enable, Midrange Purity, DCTLUI_CHECK_BOX, 0)
// DEFINE_UI_PARAMS(_ptm_low, Mid Purity Low, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_ptm_low_st, MPL Strength, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_ptm_high, Mid Purity High, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_ptm_high_st, MPH Strength, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_vl_enable, Value, DCTLUI_CHECK_BOX, 1)
// DEFINE_UI_PARAMS(_vl_r, Value R, DCTLUI_SLIDER_FLOAT, -0.33, -0.6, 0.0, 0.0)
// DEFINE_UI_PARAMS(_vl_g, Value G, DCTLUI_SLIDER_FLOAT, -0.3, -0.6, 0.0, 0.0)
// DEFINE_UI_PARAMS(_vl_b, Value B, DCTLUI_SLIDER_FLOAT, -0.2, -0.6, 0.0, 0.0)
// DEFINE_UI_PARAMS(_vl_c, Value C, DCTLUI_SLIDER_FLOAT, 0.0, -0.6, 0.0, 0.0)
// DEFINE_UI_PARAMS(_vl_m, Value M, DCTLUI_SLIDER_FLOAT, -0.2, -0.6, 0.0, 0.0)
// DEFINE_UI_PARAMS(_vl_y, Value Y, DCTLUI_SLIDER_FLOAT, 0.0, -0.6, 0.2, 0.0)
// DEFINE_UI_PARAMS(_vl_rng, Value Range, DCTLUI_SLIDER_FLOAT, 0.8, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_vl_st, Value Strength, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rgb_enable, Hueshift RGB, DCTLUI_CHECK_BOX, 0)
// DEFINE_UI_PARAMS(_hs_r, Hueshift R, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 0.6, 0.0)
// DEFINE_UI_PARAMS(_hs_g, Hueshift G, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 0.6, 0.0)
// DEFINE_UI_PARAMS(_hs_b, Hueshift B, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 0.6, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_r, Hueshift Range R, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_g, Hueshift Range G, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_b, Hueshift Range B, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hs_cmy_enable, Hueshift CMY, DCTLUI_CHECK_BOX, 0)
// DEFINE_UI_PARAMS(_hs_c, Hueshift C, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 0.6, 0.0)
// DEFINE_UI_PARAMS(_hs_m, Hueshift M, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 0.6, 0.0)
// DEFINE_UI_PARAMS(_hs_y, Hueshift Y, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 0.6, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_c, Hueshift Range C, DCTLUI_SLIDER_FLOAT, 0.0, -3.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_m, Hueshift Range M, DCTLUI_SLIDER_FLOAT, 0.0, -3.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hs_rng_y, Hueshift Range Y, DCTLUI_SLIDER_FLOAT, 0.0, -3.0, 3.0, 0.0)
// DEFINE_UI_PARAMS(_hf_enable, Hue Focus, DCTLUI_CHECK_BOX, 0)
// DEFINE_UI_PARAMS(_hf_r0, Huefocus R Low, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 0.6, 0.0)
// DEFINE_UI_PARAMS(_hf_r1, Huefocus R High, DCTLUI_SLIDER_FLOAT, 0.0, -0.6, 0.0, 0.0)
// DEFINE_UI_PARAMS(_hf_g0, Huefocus G Low, DCTLUI_SLIDER_FLOAT, 0.0, -0.8, 0.6, 0.0)
// DEFINE_UI_PARAMS(_hf_g1, Huefocus G High, DCTLUI_SLIDER_FLOAT, 0.0, -0.8, 0.0, 0.0)
// DEFINE_UI_PARAMS(_hf_b0, Huefocus B Low, DCTLUI_SLIDER_FLOAT, 0.0, -0.6, 0.6, 0.0)
// DEFINE_UI_PARAMS(_hf_b1, Huefocus B High, DCTLUI_SLIDER_FLOAT, 0.0, -0.6, 0.0, 0.0)


// DEFINE_UI_PARAMS(_display_gamut, Display Gamut, DCTLUI_COMBO_BOX, 0, {Rec709, P3D65, Rec2020}, {Rec.709, P3-D65, Rec.2020 (P3 Limited)})
// DEFINE_UI_PARAMS(_eotf, Display EOTF, DCTLUI_COMBO_BOX, 2, {eotf0, eotf1, eotf2, eotf3, eotf4, eotf5}, {Linear, 2.2 Power sRGB Display, 2.4 Power Rec.1886, 2.6 Power DCI, ST 2084 PQ, HLG})

// #define INIT_PARAMS tn_Lg=_tn_Lg, tn_gb=_tn_gb, tn_hcon_enable=_tn_hcon_enable, tn_mcon_enable=_tn_mcon_enable, ptm_enable=_ptm_enable, vl_enable=_vl_enable, hs_rgb_enable=_hs_rgb_enable, hs_cmy_enable=_hs_cmy_enable, hf_enable=_hf_enable, tn_con=_tn_con, tn_sh=_tn_sh, tn_toe=_tn_toe, tn_off=_tn_off, tn_hcon=_tn_hcon, tn_hcon_pv=_tn_hcon_pv, tn_hcon_st=_tn_hcon_st, tn_mcon=_tn_mcon, tn_mcon_w=_tn_mcon_w, tn_mcon_pc=_tn_mcon_pc, pt_r=_pt_r, pt_g=_pt_g, pt_b=_pt_b, pt_rng=_pt_rng, pt_hdr=_pt_hdr, pt_softclip=_pt_softclip, ptm_low=_ptm_low, ptm_low_st=_ptm_low_st, ptm_high=_ptm_high, ptm_high_st=_ptm_high_st, vl_r=_vl_r, vl_g=_vl_g, vl_b=_vl_b, vl_c=_vl_c, vl_m=_vl_m, vl_y=_vl_y, vl_rng=_vl_rng, vl_st=_vl_st, hs_r=_hs_r, hs_g=_hs_g, hs_b=_hs_b, hs_rng_r=_hs_rng_r, hs_rng_g=_hs_rng_g, hs_rng_b=_hs_rng_b, hs_c=_hs_c, hs_m=_hs_m, hs_y=_hs_y, hs_rng_c=_hs_rng_c, hs_rng_m=_hs_rng_m, hs_rng_y=_hs_rng_y, hf_r0=_hf_r0, hf_r1=_hf_r1, hf_g0=_hf_g0, hf_g1=_hf_g1, hf_b0=_hf_b0, hf_b1=_hf_b1, cwp_rng=cwp_rng, display_gamut=_display_gamut, eotf=_eotf;


/*---------------------------------------------------------------------------------------
  Un-Comment above this line to enable custom look creation */


// Tonescale Parameters
DEFINE_UI_PARAMS(tn_Lp, Display Peak Luminance, DCTLUI_SLIDER_FLOAT, 100.0, 100.0, 1000.0, 0.0)

// Input settings
DEFINE_UI_PARAMS(in_gamut, Input Gamut, DCTLUI_COMBO_BOX, 15, {i_xyz, i_ap0, i_ap1, i_p3d65, i_rec2020, i_rec709, i_awg3, i_awg4, i_rwg, i_sgamut3, i_sgamut3cine, i_vgamut, i_bmdwg, i_egamut, i_egamut2, i_davinciwg}, {XYZ, ACES 2065-1, ACEScg, P3D65, Rec.2020, Rec.709, Arri Wide Gamut 3, Arri Wide Gamut 4, Red Wide Gamut RGB, Sony SGamut3, Sony SGamut3Cine, Panasonic V-Gamut, Blackmagic Wide Gamut, Filmlight E-Gamut, Filmlight E-Gamut2, DaVinci Wide Gamut})
DEFINE_UI_PARAMS(in_oetf, Input Transfer Function, DCTLUI_COMBO_BOX, 1, {ioetf_linear, ioetf_davinci_intermediate, ioetf_filmlight_tlog, ioetf_arri_logc3, ioetf_arri_logc4, ioetf_panasonic_vlog, ioetf_sony_slog3, ioetf_fuji_flog}, {Linear, Davinci Intermediate, Filmlight T-Log, Arri LogC3, Arri LogC4, Panasonic V-Log, Sony S-Log3, Fuji F-Log})

// Creative White
DEFINE_UI_PARAMS(cwp, Creative White, DCTLUI_COMBO_BOX, 0, {d65, d60, d55, d50}, {D65, D60, D55, D50})
DEFINE_UI_PARAMS(cwp_rng, Creative White Range, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.0)

// Presets
DEFINE_UI_PARAMS(look_preset, Look Preset, DCTLUI_COMBO_BOX, 1, {look0, look1, look2, look3}, {Base, Default, Filmish, Custom (Check DCTL)})
DEFINE_UI_PARAMS(tonescale_preset, Tonescale Preset, DCTLUI_COMBO_BOX, 0, {tsprst0, tsprst1, tsprst2, tsprst3, tsprst4, tsprst5, tsprst6}, {High-Contrast, Low-Contrast, ACES-1.x, ACES-2.0, High-Contrast 2, Low-Contrast 2, Custom (Check DCTL)})

// Display Encoding
DEFINE_UI_PARAMS(display_encoding, Display Encoding, DCTLUI_COMBO_BOX, 0, {rec1886, srgb, p3display, rec2100pq, rec2100hlg, dolbypq, custom}, {Rec.1886 - 2.4 Power / Rec.709, sRGB Display - 2.2 Power / Rec.709, P3 Display - 2.2 Power / P3-D65, Rec.2100 - PQ / Rec.2020 (P3 Limited), Rec.2100 - HLG / Rec.2020 (P3 Limited), Dolby - PQ / P3-D65, Custom (Check DCTL)})





// Gamut Conversion Matrices
#define matrix_ap0_to_xyz make_float3x3(make_float3(0.93863094875f, -0.00574192055f, 0.017566898852f), make_float3(0.338093594922f, 0.727213902811f, -0.065307497733f), make_float3(0.000723121511f, 0.000818441849f, 1.0875161874f))
#define matrix_ap1_to_xyz make_float3x3(make_float3(0.652418717672f, 0.127179925538f, 0.170857283842f), make_float3(0.268064059194f, 0.672464478993f, 0.059471461813f), make_float3(-0.00546992851f, 0.005182799977f, 1.08934487929f))
#define matrix_rec709_to_xyz make_float3x3(make_float3(0.412390917540f, 0.357584357262f, 0.180480793118f), make_float3(0.212639078498f, 0.715168714523f, 0.072192311287f), make_float3(0.019330825657f, 0.119194783270f, 0.950532138348f))
#define matrix_p3d65_to_xyz make_float3x3(make_float3(0.486571133137f, 0.265667706728f, 0.198217317462f), make_float3(0.228974640369f, 0.691738605499f, 0.079286918044f), make_float3(0.0f, 0.045113388449, 1.043944478035f))
#define matrix_xyz_to_p3d65 make_float3x3(make_float3(2.49349691194f, -0.931383617919f, -0.402710784451f), make_float3(-0.829488969562f, 1.76266406032f, 0.023624685842f), make_float3(0.035845830244f, -0.076172389268f, 0.956884524008f))
#define matrix_rec2020_to_xyz make_float3x3(make_float3(0.636958122253f, 0.144616916776f, 0.168880969286f), make_float3(0.262700229883f, 0.677998125553f, 0.059301715344f), make_float3(0.0f, 0.028072696179, 1.060985088348f))
#define matrix_arriwg3_to_xyz make_float3x3(make_float3(0.638007619284f, 0.214703856337f, 0.097744451431f), make_float3(0.291953779f, 0.823841041511f, -0.11579482051f), make_float3(0.002798279032f, -0.067034235689f, 1.15329370742f))
#define matrix_arriwg4_to_xyz make_float3x3(make_float3(0.704858320407f, 0.12976029517f, 0.115837311474f), make_float3(0.254524176404f, 0.781477732712f, -0.036001909116f), make_float3(0.0f, 0.0f, 1.08905775076f))
#define matrix_redwg_to_xyz make_float3x3(make_float3(0.735275208950f, 0.068609409034f, 0.146571278572f), make_float3(0.286694079638f, 0.842979073524f, -0.129673242569f), make_float3(-0.079680845141f, -0.347343206406, 1.516081929207f))
#define matrix_sonysgamut3_to_xyz make_float3x3(make_float3(0.706482713192f, 0.128801049791f, 0.115172164069f), make_float3(0.270979670813f, 0.786606411221f, -0.057586082034f), make_float3(-0.009677845386f, 0.004600037493f, 1.09413555865f))
#define matrix_sonysgamut3cine_to_xyz make_float3x3(make_float3(0.599083920758f, 0.248925516115f, 0.102446490178f), make_float3(0.215075820116f, 0.885068501744f, -0.100144321859f), make_float3(-0.032065849545f, -0.027658390679f, 1.14878199098f))
#define matrix_vgamut_to_xyz make_float3x3(make_float3(0.679644469878f, 0.15221141244f, 0.118600044733), make_float3(0.26068555009f, 0.77489446333f, -0.03558001342), make_float3(-0.009310198218f, -0.004612467044f, 1.10298041602))
#define matrix_bmdwg_to_xyz make_float3x3(make_float3(0.606538414955f, 0.220412746072f, 0.123504832387f), make_float3(0.267992943525f, 0.832748472691f, -0.100741356611f), make_float3(-0.029442556202f, -0.086612440646, 1.205112814903f))
#define matrix_egamut_to_xyz make_float3x3(make_float3(0.705396831036f, 0.164041340351f, 0.081017754972f), make_float3(0.280130714178f, 0.820206701756f, -0.100337378681f), make_float3(-0.103781513870f, -0.072907261550, 1.265746593475f))
#define matrix_egamut2_to_xyz make_float3x3(make_float3(0.736477700184f, 0.130739651087f, 0.083238575781f), make_float3(0.275069984406f, 0.828017790216f, -0.103087774621f), make_float3(-0.124225154248f, -0.087159767391f, 1.3004426724f))
#define matrix_davinciwg_to_xyz make_float3x3(make_float3(0.700622320175f, 0.148774802685f, 0.101058728993f), make_float3(0.274118483067f, 0.873631775379f, -0.147750422359f), make_float3(-0.098962903023f, -0.137895315886, 1.325916051865f))

// Display gamuts with Normalized adaptation matrices for other creative whitepoints (CAT02)
#define matrix_p3_to_p3_d50 make_float3x3(make_float3(0.9287127388f, 0.06578032793f, 0.005506708345f), make_float3(-0.002887159176f, 0.8640709228f, 4.3593718e-05f), make_float3(-0.001009551548f, -0.01073503317f, 0.6672692039f))
#define matrix_p3_to_p3_d55 make_float3x3(make_float3(0.9559790976f, 0.0403850003f, 0.003639287409f), make_float3(-0.001771929896f, 0.9163058305f, 3.3300759e-05f), make_float3(-0.000674760809f, -0.0072466358f, 0.7831189153f))
#define matrix_p3_to_p3_d60 make_float3x3(make_float3(0.979832881f, 0.01836378979f, 0.001803284786f), make_float3(-0.000805359793f, 0.9618000331f, 1.8876121e-05f), make_float3(-0.000338382322f, -0.003671835795f, 0.894139105f))
#define matrix_p3_to_rec709_d50 make_float3x3(make_float3(1.103807322f, -0.1103425121f, 0.006531676079f), make_float3(-0.04079386701f, 0.8704694227f, -0.000180522628f), make_float3(-0.01854055914f, -0.07857582481f, 0.7105498861f))
#define matrix_p3_to_rec709_d55 make_float3x3(make_float3(1.149327514f, -0.1536910745f, 0.004366526746f), make_float3(-0.0412590771f, 0.9351717477f, -0.000116126221f), make_float3(-0.01900949528f, -0.07928282823f, 0.8437884317f))
#define matrix_p3_to_rec709_d60 make_float3x3(make_float3(1.189986856f, -0.192168414f, 0.002185496045f), make_float3(-0.04168263635f, 0.9927757018f, -5.5660878e-05f), make_float3(-0.01937995127f, -0.07933006919f, 0.9734397041f))
#define matrix_p3_to_rec709_d65 make_float3x3(make_float3(1.224940181f, -0.2249402404f, 0.0f), make_float3(-0.04205697775f, 1.042057037f, -1.4901e-08f), make_float3(-0.01963755488f, -0.07863604277f, 1.098273635f))
#define matrix_p3_to_rec2020 make_float3x3(make_float3(0.7538330344f, 0.1985973691f, 0.04756959659f), make_float3(0.04574384897f, 0.9417772198f, 0.01247893122f), make_float3(-0.001210340355f, 0.0176017173f, 0.9836086231f))


/* Math helper functions ----------------------------*/

__CONSTANT__ float SQRT3 = 1.73205080756887729353f;

typedef struct {
  float3 x, y, z;
} float3x3;

// Helper function to create a float3x3
__DEVICE__ float3x3 make_float3x3(float3 a, float3 b, float3 c) {
  float3x3 d;
  d.x = a, d.y = b, d.z = c;
  return d;
}

// Return identity 3x3 matrix
__DEVICE__ float3x3 identity() {
  return make_float3x3(make_float3(1.0f, 0.0f, 0.0f), make_float3(0.0f, 1.0f, 0.0f), make_float3(0.0f, 0.0f, 1.0f));
}

// Multiply 3x3 matrix m and float3 vector v
__DEVICE__ float3 vdot(float3x3 m, float3 v) {
  return make_float3(m.x.x*v.x + m.x.y*v.y + m.x.z*v.z, m.y.x*v.x + m.y.y*v.y + m.y.z*v.z, m.z.x*v.x + m.z.y*v.y + m.z.z*v.z);
}

// Safe division of float a by float b
__DEVICE__ float sdivf(float a, float b) {
  if (b == 0.0f) return 0.0f;
  else return a/b;
}

// Safe division of float3 a by float b
__DEVICE__ float3 sdivf3f(float3 a, float b) {
  return make_float3(sdivf(a.x, b), sdivf(a.y, b), sdivf(a.z, b));
}

// Safe element-wise division of float3 a by float3 b
__DEVICE__ float3 sdivf3f3(float3 a, float3 b) {
  return make_float3(sdivf(a.x, b.x), sdivf(a.y, b.y), sdivf(a.z, b.z));
}

// Safe power function raising float a to power float b
__DEVICE__ float spowf(float a, float b) {
  if (a <= 0.0f) return a;
  else return _powf(a, b);
}

// Safe power function raising float3 a to power float b
__DEVICE__ float3 spowf3(float3 a, float b) {
  return make_float3(spowf(a.x, b), spowf(a.y, b), spowf(a.z, b));
}

// Return the hypot or vector length of float3 a
__DEVICE__ float hypotf3(float3 a) { return _sqrtf(a.x*a.x + a.y*a.y + a.z*a.z); }

// Return the min of float3 a
__DEVICE__ float fmaxf3(float3 a) { return _fmaxf(a.x, _fmaxf(a.y, a.z)); }

// Return the max of float3 a
__DEVICE__ float fminf3(float3 a) { return _fminf(a.x, _fminf(a.y, a.z)); }

// Clamp float3 a to max value mx
__DEVICE__ float3 clampmaxf3(float3 a, float mx) { return make_float3(_fminf(a.x, mx), _fminf(a.y, mx), _fminf(a.z, mx)); }

// Clamp float3 a to min value mn
__DEVICE__ float3 clampminf3(float3 a, float mn) { return make_float3(_fmaxf(a.x, mn), _fmaxf(a.y, mn), _fmaxf(a.z, mn)); }

// Clamp float3 a to min value mn and max value mx
__DEVICE__ float clampf(float a, float mn, float mx) { return _fminf(_fmaxf(a, mn), mx); }
__DEVICE__ float3 clampf3(float3 a, float mn, float mx) { return make_float3(clampf(a.x, mn, mx), clampf(a.y, mn, mx), clampf(a.z, mn, mx)); }


/* OETF Linearization Transfer Functions ---------------------------------------- */

__DEVICE__ float oetf_davinci_intermediate(float x) {
    return x <= 0.02740668f ? x/10.44426855f : _exp2f(x/0.07329248f - 7.0f) - 0.0075f;
}
__DEVICE__ float oetf_filmlight_tlog(float x) {
  return x < 0.075f ? (x-0.075f)/16.184376489665897f : _expf((x - 0.5520126568606655f)/0.09232902596577353f) - 0.0057048244042473785f;
}
__DEVICE__ float oetf_arri_logc3(float x) {
  return x < 5.367655f*0.010591f + 0.092809f ? (x - 0.092809f)/5.367655f : (_exp10f((x - 0.385537f)/0.247190f) - 0.052272f)/5.555556f;
}
__DEVICE__ float oetf_arri_logc4(float x) {
  return x < -0.7774983977293537f ? x*0.3033266726886969f - 0.7774983977293537f : (_exp2f(14.0f*(x - 0.09286412512218964f)/0.9071358748778103f + 6.0f) - 64.0f)/2231.8263090676883f;
}
__DEVICE__ float oetf_panasonic_vlog(float x) {
  return x < 0.181f ? (x - 0.125f)/5.6f : _exp10f((x - 0.598206f)/0.241514f) - 0.00873f;
}
__DEVICE__ float oetf_sony_slog3(float x) {
  return x < 171.2102946929f/1023.0f ? (x*1023.0f - 95.0f)*0.01125f/(171.2102946929f - 95.0f) : (_exp10f(((x*1023.0f - 420.0f)/261.5f))*(0.18f + 0.01f) - 0.01f);
}
__DEVICE__ float oetf_fujifilm_flog(float x) {
  return x < 0.1005377752f ? (x - 0.092864f)/8.735631f : (_exp10f(((x - 0.790453f)/0.344676f))/0.555556f - 0.009468f/0.555556f);
}


__DEVICE__ float3 linearize(float3 rgb, int tf) {
  if (tf==0) { // Linear
    return rgb;
  } else if (tf==1) { // Davinci Intermediate
    rgb.x = oetf_davinci_intermediate(rgb.x);
    rgb.y = oetf_davinci_intermediate(rgb.y);
    rgb.z = oetf_davinci_intermediate(rgb.z);
  } else if (tf==2) { // Filmlight T-Log
    rgb.x = oetf_filmlight_tlog(rgb.x);
    rgb.y = oetf_filmlight_tlog(rgb.y);
    rgb.z = oetf_filmlight_tlog(rgb.z);
  } else if (tf==3) { // Arri LogC3
    rgb.x = oetf_arri_logc3(rgb.x);
    rgb.y = oetf_arri_logc3(rgb.y);
    rgb.z = oetf_arri_logc3(rgb.z);
  } else if (tf==4) { // Arri LogC4
    rgb.x = oetf_arri_logc4(rgb.x);
    rgb.y = oetf_arri_logc4(rgb.y);
    rgb.z = oetf_arri_logc4(rgb.z);
  } else if (tf==5) { // Panasonic V-Log
    rgb.x = oetf_panasonic_vlog(rgb.x);
    rgb.y = oetf_panasonic_vlog(rgb.y);
    rgb.z = oetf_panasonic_vlog(rgb.z);
  } else if (tf==6) { // Sony S-Log3
    rgb.x = oetf_sony_slog3(rgb.x);
    rgb.y = oetf_sony_slog3(rgb.y);
    rgb.z = oetf_sony_slog3(rgb.z);
  } else if (tf==7) { // Fuji F-Log
    rgb.x = oetf_fujifilm_flog(rgb.x);
    rgb.y = oetf_fujifilm_flog(rgb.y);
    rgb.z = oetf_fujifilm_flog(rgb.z);
  }
  return rgb;
}



/* EOTF Transfer Functions ---------------------------------------- */

__DEVICE__ float3 eotf_hlg(float3 rgb, int inverse) {
  /* Apply the HLG Forward or Inverse EOTF for 1000 nits. 
      ITU-R Rec BT.2100-2 https://www.itu.int/rec/R-REC-BT.2100 
      ITU-R Rep BT.2390-8: https://www.itu.int/pub/R-REP-BT.2390
  */
  
  if (inverse == 1) {
    float Yd = 0.2627f*rgb.x + 0.6780f*rgb.y + 0.0593f*rgb.z;
    rgb = rgb*spowf(Yd, (1.0f - 1.2f)/1.2f);
    rgb.x = rgb.x <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.x) : 0.17883277f*_logf(12.0f*rgb.x - 0.28466892f) + 0.55991073f;
    rgb.y = rgb.y <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.y) : 0.17883277f*_logf(12.0f*rgb.y - 0.28466892f) + 0.55991073f;
    rgb.z = rgb.z <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.z) : 0.17883277f*_logf(12.0f*rgb.z - 0.28466892f) + 0.55991073f;
  } else {
    rgb.x = rgb.x <= 0.5f ? rgb.x*rgb.x/3.0f : (_expf((rgb.x - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    rgb.y = rgb.y <= 0.5f ? rgb.y*rgb.y/3.0f : (_expf((rgb.y - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    rgb.z = rgb.z <= 0.5f ? rgb.z*rgb.z/3.0f : (_expf((rgb.z - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    float Ys = 0.2627f*rgb.x + 0.6780f*rgb.y + 0.0593f*rgb.z;
    rgb = rgb*spowf(Ys, 1.2f - 1.0f);
  }
  return rgb;
}


__DEVICE__ float3 eotf_pq(float3 rgb, int inverse) {
  /* Apply the ST-2084 PQ Forward or Inverse EOTF
      ITU-R Rec BT.2100-2 https://www.itu.int/rec/R-REC-BT.2100
      ITU-R Rep BT.2390-9 https://www.itu.int/pub/R-REP-BT.2390
      Note: in the spec there is a normalization for peak display luminance. 
      For this function we assume the input is already normalized such that 1.0 = 10,000 nits
  */
  
  const float m1 = 2610.0f/16384.0f;
  const float m2 = 2523.0f/32.0f;
  const float c1 = 107.0f/128.0f;
  const float c2 = 2413.0f/128.0f;
  const float c3 = 2392.0f/128.0f;

  if (inverse == 1) {
    rgb = spowf3(rgb, m1);
    rgb = spowf3((c1 + c2*rgb)/(1.0f + c3*rgb), m2);
  } else {
    rgb = spowf3(rgb, 1.0f/m2);
    rgb = spowf3((rgb - c1)/(c2 - c3*rgb), 1.0f/m1);
  }
  return rgb;
}


/* Functions for OpenDRT ---------------------------------------- */

__DEVICE__ float compress_powerp(float x, float p) {
  // Unconstrained variable slope compression function. https://www.desmos.com/calculator/flquiy0s0y
  return x < 0.0f ? x : x*spowf(1.0f + spowf(x, 1.0f/p), -p);
}

__DEVICE__ float compress_hyperbolic_power(float x, float s, float p) {
  // Simple hyperbolic compression function https://www.desmos.com/calculator/ofwtcmzc3w
  return spowf(x/(x + s), p);
}

__DEVICE__ float compress_toe_quadratic(float x, float toe, int inv) {
  // Quadratic toe compress function https://www.desmos.com/calculator/skk8ahmnws
  if (toe == 0.0f) return x;
  if (inv == 0) {
    return spowf(x, 2.0f)/(x + toe);
  } else {
    return (x + _sqrtf(x*(4.0f*toe + x)))/2.0f;
  }
}

__DEVICE__ float compress_toe_cubic(float x, float m, float w, int inv) {
  // https://www.desmos.com/calculator/ubgteikoke
  if (m==1.0f) return x;
  float x2 = x*x;
  if (inv == 0) {
    return x*(x2 + m*w)/(x2 + w);
  } else {
    float p0 = x2 - 3.0f*m*w;
    float p1 = 2.0f*x2 + 27.0f*w - 9.0f*m*w;
    float p2 = _powf(_sqrtf(x2*p1*p1 - 4*p0*p0*p0)/2.0f + x*p1/2.0f, 1.0f/3.0f);
    return p0/(3.0f*p2) + p2/3.0f + x/3.0f;
  }
}

__DEVICE__ float contrast_high(float x, float p, float pv, float pv_lx, int inv) {
  // High exposure adjustment with linear extension
  // https://www.desmos.com/calculator/etjgwyrgad
  const float x0 = 0.18f*_powf(2.0f, pv);
  if (x < x0 || p == 1.0f) return x;

  const float o = x0 - x0/p;
  const float s0 = _powf(x0, 1.0f - p)/p;
  const float x1 = x0*_powf(2.0f, pv_lx);
  const float k1 = p*s0*_powf(x1, p)/x1;
  const float y1 = s0*_powf(x1, p) + o;
  if (inv==1)
    return x > y1 ? (x - y1)/k1 + x1 : _powf((x - o)/s0, 1.0f/p);
  else
    return x > x1 ? k1*(x - x1) + y1 : s0*_powf(x, p) + o;
}


__DEVICE__ float3 narrow_ha(float3 c) {
  return make_float3(_fmaxf(0.0f, c.x - (c.y + c.z)), _fmaxf(0.0f, c.y - (c.x + c.z)), _fmaxf(0.0f, c.z - (c.x + c.y)));
}






__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
  float3 rgb = make_float3(p_R, p_G, p_B);

  /*****************************************************
    Parameter Setup
    --------------------------------------------------*/
  
  // Init look preset variables
  int tn_hcon_enable, tn_mcon_enable, ptm_enable, vl_enable, hs_rgb_enable, hs_cmy_enable, hf_enable, display_gamut, eotf;
  float tn_Lg, tn_gb, tn_con, tn_sh, tn_toe, tn_off, tn_hcon, tn_hcon_pv, tn_hcon_st, tn_mcon, tn_mcon_w, tn_mcon_pc, pt_r, pt_g, pt_b, pt_rng, pt_hdr, pt_softclip, ptm_low, ptm_low_st, ptm_high, ptm_high_st, vl_r, vl_g, vl_b, vl_c, vl_m, vl_y, vl_rng, vl_st, hs_r, hs_g, hs_b, hs_rng_r, hs_rng_g, hs_rng_b, hs_c, hs_m, hs_y, hs_rng_c, hs_rng_m, hs_rng_y, hf_r0, hf_r1, hf_g0, hf_g1, hf_b0, hf_b1;
  
  tn_gb = 0.13f;

  INIT_PARAMS


  if (look_preset==0) { // base
    tn_Lg = 11.1f, tn_gb = 0.13f, tn_con = 1.4f, tn_sh = 0.5f, tn_toe = 0.001f, tn_off = 0.002f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 0.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 1, tn_mcon = 0.8f, tn_mcon_w = 0.7f, tn_mcon_pc = 1.0f, pt_r = 0.4f, pt_g = 0.3f, pt_b = 1.3f, pt_rng = 0.25f, pt_hdr = 0.5f, pt_softclip = 1, ptm_enable = 0, ptm_low = 0.0f, ptm_low_st = 0.5f, ptm_high = 0.0f, ptm_high_st = 0.5f, vl_enable = 1, vl_r = -0.33f, vl_g = -0.3f, vl_b = -0.2f, vl_c = 0.0f, vl_m = -0.2f, vl_y = 0.0f, vl_rng = 0.8f, vl_st = 0.5f, hs_rgb_enable = 0, hs_r = 0.0f, hs_g = 0.0f, hs_b = 0.0f, hs_rng_r = 0.0f, hs_rng_g = 0.0f, hs_rng_b = 0.0f, hs_cmy_enable = 0, hs_c = 0.0f, hs_m = 0.0f, hs_y = 0.0f, hs_rng_c = 0.0f, hs_rng_m = 0.0f, hs_rng_y = 0.0f, hf_enable = 0, hf_r0 = 0.0f, hf_r1 = 0.0f, hf_g0 = 0.0f, hf_g1 = 0.0f, hf_b0 = 0.0f, hf_b1 = 0.0f;
  }
  else if (look_preset==1) { // default
    tn_Lg = 11.1f, tn_gb = 0.13f, tn_con = 1.4f, tn_sh = 0.5f, tn_toe = 0.001f, tn_off = 0.002f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 0.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 1, tn_mcon = 0.8f, tn_mcon_w = 0.7f, tn_mcon_pc = 1.0f, pt_r = 0.4f, pt_g = 0.3f, pt_b = 1.3f, pt_rng = 0.25f, pt_hdr = 0.5f, pt_softclip = 1, ptm_enable = 1, ptm_low = 0.5f, ptm_low_st = 0.5f, ptm_high = 0.66f, ptm_high_st = 0.5f, vl_enable = 1, vl_r = -0.33f, vl_g = -0.3f, vl_b = -0.2f, vl_c = 0.0f, vl_m = -0.2f, vl_y = 0.0f, vl_rng = 0.8f, vl_st = 0.5f, hs_rgb_enable = 1, hs_r = 0.35f, hs_g = 0.2f, hs_b = 0.25f, hs_rng_r = 0.2f, hs_rng_g = 2.0f, hs_rng_b = 0.5f, hs_cmy_enable = 0, hs_c = 0.0f, hs_m = 0.0f, hs_y = 0.0f, hs_rng_c = 0.0f, hs_rng_m = 0.0f, hs_rng_y = 0.0f, hf_enable = 1, hf_r0 = 0.25f, hf_r1 = -0.5f, hf_g0 = 0.2f, hf_g1 = -0.3f, hf_b0 = 0.1f, hf_b1 = -0.1f;
  }
  else if (look_preset==2) { // filmish
    tn_Lg = 11.1f, tn_gb = 0.13f, tn_con = 1.4f, tn_sh = 0.5f, tn_toe = 0.001f, tn_off = 0.002f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 0.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 1, tn_mcon = 0.8f, tn_mcon_w = 0.7f, tn_mcon_pc = 1.0f, pt_r = 0.15f, pt_g = 0.2f, pt_b = 1.0f, pt_rng = 0.25f, pt_hdr = 0.5f, pt_softclip = 1, ptm_enable = 1, ptm_low = 0.8f, ptm_low_st = 0.6f, ptm_high = 1.0f, ptm_high_st = 0.5f, vl_enable = 1, vl_r = -0.43f, vl_g = -0.4f, vl_b = -0.3f, vl_c = -0.2f, vl_m = -0.4f, vl_y = 0.0f, vl_rng = 1.0f, vl_st = 0.6f, hs_rgb_enable = 1, hs_r = 0.4f, hs_g = 0.4f, hs_b = 0.3f, hs_rng_r = 0.8f, hs_rng_g = 2.0f, hs_rng_b = 1.0f, hs_cmy_enable = 1, hs_c = 0.398f, hs_m = 0.4f, hs_y = 0.5f, hs_rng_c = 0.5f, hs_rng_m = 1.0f, hs_rng_y = 0.0f, hf_enable = 1, hf_r0 = 0.15f, hf_r1 = -0.5f, hf_g0 = -0.5f, hf_g1 = -0.5f, hf_b0 = -0.2f, hf_b1 = 0.0f;
  }
  

  if (tonescale_preset==0) { // high-contrast
    tn_Lg = 11.1f, tn_con = 1.4f, tn_sh = 0.5f, tn_toe = 0.001f, tn_off = 0.002f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 0.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 1, tn_mcon = 0.8f, tn_mcon_w = 0.7f, tn_mcon_pc = 1.0f;
  }
  else if (tonescale_preset==1) { // low-contrast
    tn_Lg = 11.1f, tn_con = 1.4f, tn_sh = 0.5f, tn_toe = 0.001f, tn_off = 0.002f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 0.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 0, tn_mcon = 0.0f, tn_mcon_w = 0.7f, tn_mcon_pc = 1.0f;
  }
  else if (tonescale_preset==2) { // aces-1.x
    tn_Lg = 10.0f, tn_con = 1.0f, tn_sh = 0.245f, tn_toe = 0.02f, tn_off = 0.0f, tn_hcon_enable = 1, tn_hcon = 0.55f, tn_hcon_pv = 0.0f, tn_hcon_st = 2.0f, tn_mcon_enable = 1, tn_mcon = 1.13f, tn_mcon_w = 1.0f, tn_mcon_pc = 1.0f;
  }
  else if (tonescale_preset==3) { // aces-2.0
    tn_Lg = 10.0f, tn_con = 1.15f, tn_sh = 0.5f, tn_toe = 0.04f, tn_off = 0.0f, tn_hcon_enable = 0, tn_hcon = 1.0f, tn_hcon_pv = 1.0f, tn_hcon_st = 1.0f, tn_mcon_enable = 0, tn_mcon = 1.0f, tn_mcon_w = 0.6f, tn_mcon_pc = 1.0f;
  }
  else if (tonescale_preset==4) { // high-contrast2
    tn_Lg = 6.0f, tn_con = 1.5f, tn_sh = 0.5f, tn_toe = 0.003f, tn_off = 0.01f, tn_hcon_enable = 1, tn_hcon = 0.25f, tn_hcon_pv = 0.0f, tn_hcon_st = 4.0f, tn_mcon_enable = 1, tn_mcon = 1.0f, tn_mcon_w = 1.0f, tn_mcon_pc = 1.0f;
  }
  else if (tonescale_preset==5) { // low-contrast2
    tn_Lg = 11.1f, tn_con = 1.2f, tn_sh = 0.5f, tn_toe = 0.01f, tn_off = 0.005f, tn_hcon_enable = 0, tn_hcon = 0.0f, tn_hcon_pv = 0.0f, tn_hcon_st = 2.0f, tn_mcon_enable = 1, tn_mcon = 1.0f, tn_mcon_w = 0.25f, tn_mcon_pc = 1.0f;
  }


  // Creative White
  if (cwp==0) cwp = 0;
  else if (cwp==1) cwp = 1;
  else if (cwp==2) cwp = 2;
  else if (cwp==3) cwp = 3;


  float3x3 in_to_xyz;
  if (in_gamut==0) in_to_xyz = identity();
  else if (in_gamut==1) in_to_xyz = matrix_ap0_to_xyz;
  else if (in_gamut==2) in_to_xyz = matrix_ap1_to_xyz;
  else if (in_gamut==3) in_to_xyz = matrix_p3d65_to_xyz;
  else if (in_gamut==4) in_to_xyz = matrix_rec2020_to_xyz;
  else if (in_gamut==5) in_to_xyz = matrix_rec709_to_xyz;
  else if (in_gamut==6) in_to_xyz = matrix_arriwg3_to_xyz;
  else if (in_gamut==7) in_to_xyz = matrix_arriwg4_to_xyz;
  else if (in_gamut==8) in_to_xyz = matrix_redwg_to_xyz;
  else if (in_gamut==9) in_to_xyz = matrix_sonysgamut3_to_xyz;
  else if (in_gamut==10) in_to_xyz = matrix_sonysgamut3cine_to_xyz;
  else if (in_gamut==11) in_to_xyz = matrix_vgamut_to_xyz;
  else if (in_gamut==12) in_to_xyz = matrix_bmdwg_to_xyz;
  else if (in_gamut==13) in_to_xyz = matrix_egamut_to_xyz;
  else if (in_gamut==14) in_to_xyz = matrix_egamut2_to_xyz;
  else if (in_gamut==15) in_to_xyz = matrix_davinciwg_to_xyz;



  if (display_encoding==0) { // Rec.1886
    display_gamut = 0;
    eotf = 2;
  }
  else if (display_encoding==1) { // sRGB Display
    display_gamut = 0;
    eotf = 1;
  }
  else if (display_encoding==2) { // Display P3
    display_gamut = 1;
    eotf = 1;
  }
  else if (display_encoding==3) { // Rec.2100 PQ
    display_gamut = 2;
    eotf = 4;
  }
  else if (display_encoding==4) { // Rec.2100 HLG
    display_gamut = 2;
    eotf = 5;
  }
  else if (display_encoding==4) { // Dolby PQ
    display_gamut = 1;
    eotf = 4;
  }

  

  // Linearize if a non-linear input oetf / transfer function is selected
  if (in_oetf==1) {
    rgb.x = oetf_davinci_intermediate(rgb.x);
    rgb.y = oetf_davinci_intermediate(rgb.y);
    rgb.z = oetf_davinci_intermediate(rgb.z);
  } else if (in_oetf==2) {
    rgb.x = oetf_filmlight_tlog(rgb.x);
    rgb.y = oetf_filmlight_tlog(rgb.y);
    rgb.z = oetf_filmlight_tlog(rgb.z);
  } else if (in_oetf==3) {
    rgb.x = oetf_arri_logc3(rgb.x);
    rgb.y = oetf_arri_logc3(rgb.y);
    rgb.z = oetf_arri_logc3(rgb.z);
  } else if (in_oetf==4) {
    rgb.x = oetf_arri_logc4(rgb.x);
    rgb.y = oetf_arri_logc4(rgb.y);
    rgb.z = oetf_arri_logc4(rgb.z);
  } else if (in_oetf==5) {
    rgb.x = oetf_panasonic_vlog(rgb.x);
    rgb.y = oetf_panasonic_vlog(rgb.y);
    rgb.z = oetf_panasonic_vlog(rgb.z);
  } else if (in_oetf==6) {
    rgb.x = oetf_sony_slog3(rgb.x);
    rgb.y = oetf_sony_slog3(rgb.y);
    rgb.z = oetf_sony_slog3(rgb.z);
  } else if (in_oetf==7) {
    rgb.x = oetf_fujifilm_flog(rgb.x);
    rgb.y = oetf_fujifilm_flog(rgb.y);
    rgb.z = oetf_fujifilm_flog(rgb.z);
  }

  /***************************************************
    Tonescale Constraint Calculations
    https://www.desmos.com/calculator/1c4fhzy3bw

    These could be pre-calculated but there is no way to do this in DCTL.
    Anything that is const should be precalculated and not run per-pixel
    --------------------------------------------------*/
  const float ts_x1 = _powf(2.0f, 6.0f*tn_sh + 4.0f);
  const float ts_y1 = tn_Lp/100.0f;
  const float ts_x0 = 0.18f + tn_off;
  const float ts_y0 = tn_Lg/100.0f*(1.0f + tn_gb*_log2f(ts_y1));
  const float ts_s0 = compress_toe_quadratic(ts_y0, tn_toe, 1);
  const float ts_s10 = ts_x0*(_powf(ts_s0, -1.0f/tn_con) - 1.0f);
  const float ts_m1 = ts_y1/_powf(ts_x1/(ts_x1 + ts_s10), tn_con);
  const float ts_m2 = compress_toe_quadratic(ts_m1, tn_toe, 1);
  const float ts_s = ts_x0*(_powf(ts_s0/ts_m2, -1.0f/tn_con) - 1.0f);
  const float ts_dsc = eotf==4 ? 0.01 : eotf==5 ? 0.1 : 100.0f/tn_Lp;

  // Lerp from pt_cmp at 100 nits to pt_cmp_hdr at 1000 nits
  const float pt_cmp_Lf = (tn_Lp - 100.0f)/900.0f;
  const float ts_s1 = ts_s/((ts_s*pt_cmp_Lf + 1.0f - pt_cmp_Lf)*(1.0f - pt_hdr) + pt_hdr);
  

  // Convert from input gamut into P3-D65
  rgb = vdot(in_to_xyz, rgb);
  rgb = vdot(matrix_xyz_to_p3d65, rgb);


  // Rendering Space: "Desaturate" to control scale of the color volume in the rgb ratios
  float3 rs_w = make_float3(0.2f, 0.55f, 0.25f); // render space weights
  float rs_sa = 0.4f; // render space "desaturation"
  float sat_L = rgb.x*rs_w.x + rgb.y*rs_w.y + rgb.z*rs_w.z;
  rgb = sat_L*rs_sa + rgb*(1.0f - rs_sa);
  

  // Offset
  rgb += tn_off;


  /***************************************************
    Midtone Contrast Module
  --------------------------------------------------*/
  if (tn_mcon_enable) {
    float mcon_m = _powf(2.0f, -tn_mcon);
    float mcon_w = tn_mcon_w/4.0f;
    mcon_w *= mcon_w;

    // Normalize for ts_x0 intersection constraint
    const float mcon_cnst_sc = compress_toe_cubic(ts_x0, mcon_m, mcon_w, 1)/ts_x0;
    rgb *= mcon_cnst_sc;
   
    // Apply per-channel midtone contrast
    float3 mcon_rgb = rgb;
    mcon_rgb.x = compress_toe_cubic(rgb.x, mcon_m, mcon_w, 0);
    mcon_rgb.y = compress_toe_cubic(rgb.y, mcon_m, mcon_w, 0);
    mcon_rgb.z = compress_toe_cubic(rgb.z, mcon_m, mcon_w, 0);
    
    // Scale for ratio-preserving midtone contrast
    float mcon_nm = hypotf3(clampminf3(rgb, 0.0f))/SQRT3;
    float mcon_sc = (mcon_nm*mcon_nm + mcon_m*mcon_w)/(mcon_nm*mcon_nm + mcon_w);
    
    // Always use some amount of ratio-preserving method towards gamut boundary
    float mcon_mx = fmaxf3(rgb);
    float mcon_mn = fminf3(rgb);
    float mcon_ch = clampf(1.0f - sdivf(mcon_mn, mcon_mx), 0.0, 1.0);
    mcon_ch = _powf(mcon_ch, 4.0f*tn_mcon_pc);

    rgb = mcon_sc*rgb*mcon_ch + mcon_rgb*(1.0f - mcon_ch);
  }


  // Tonescale Norm
  float tsn = hypotf3(clampminf3(rgb, 0.0f))/SQRT3;

  // Purity Compression Norm
  float ts_pt = _sqrtf(_fmaxf(0.0f, rgb.x*rgb.x*pt_r) + _fmaxf(0.0f, rgb.y*rgb.y*pt_g) + _fmaxf(0.0f, rgb.z*rgb.z*pt_b));

  // RGB Ratios
  rgb = sdivf3f(clampminf3(rgb, -2.0f), tsn);

  
  // Apply High Contrast
  if (tn_hcon_enable) {
    float hcon_p = _powf(2.0f, tn_hcon);
    tsn = contrast_high(tsn, hcon_p, tn_hcon_pv, tn_hcon_st, 0);
    ts_pt = contrast_high(ts_pt, hcon_p, tn_hcon_pv, tn_hcon_st, 0);
  }


  // Apply tonescale
  tsn = compress_hyperbolic_power(tsn, ts_s, tn_con);


  ts_pt = compress_hyperbolic_power(ts_pt, ts_s1, tn_con);
  
  // Purity Compression Range
  float ts_pt_cmp = _powf(ts_pt, 1.0f/pt_rng);


  // RGB CMY Hue Angles
  float mn = _fmaxf(0.0f, fminf3(rgb));
  float3 ha_rgb = narrow_ha(rgb - mn);
  float3 rats_mx_div = sdivf3f(rgb, fmaxf3(rgb));
  float rats_mx_div_mn = _fmaxf(0.0f, fminf3(rats_mx_div));
  float3 ha_cmy_wide = clampminf3(1.0f - rats_mx_div, 0.0f);
  float3 ha_cmy = narrow_ha(ha_cmy_wide);



  /***************************************************
    Hue Focus
  --------------------------------------------------*/
  if (hf_enable) {
    // Limit to mid-range purity
    float mn_sqrt = _sqrtf(mn);
    float3 hf_rgb = make_float3(ha_rgb.x*mn_sqrt, ha_rgb.y*mn_sqrt, ha_rgb.z*mn);
    float hf_tsn = 1.0f - tsn;
    hf_tsn *= hf_tsn;
    // Bias focus based on tonescale using Lift/Mult: https://www.desmos.com/calculator/gzbgov62hl
    float3 hff = make_float3(
      (hf_tsn*(hf_r1 - hf_r0) - hf_r1),
      (hf_tsn*(hf_g1 - hf_g0) - hf_g1),
      (hf_tsn*(hf_b1 - hf_b0) - hf_b1));
    hff *= hf_rgb;
    hff = make_float3(
      hff.y + hff.z + 1.0f,
      hff.x + hff.z + 1.0f, 
      hff.x + hff.y + 1.0f);
    rgb *= hff;
  }



  /***************************************************
    Hue Shift
  --------------------------------------------------*/
  // Hue Shift RGB
  if (hs_rgb_enable) {
    float3 hs_rgb = make_float3(
      _powf(ts_pt_cmp, _powf(2.0f, -hs_rng_r)),
      _powf(ts_pt_cmp, _powf(2.0f, -hs_rng_g)),
      _powf(ts_pt_cmp, _powf(2.0f, -hs_rng_b)));
    hs_rgb *= ha_rgb;
    float3 hsf = make_float3(hs_rgb.x*hs_r, hs_rgb.y*-hs_g, hs_rgb.z*-hs_b);
    hsf = make_float3(hsf.z - hsf.y, hsf.x - hsf.z, hsf.y - hsf.x);
    rgb += hsf;
  }

  // Hue Shift CMY
  if (hs_cmy_enable) {
    float3 hs_cmy = make_float3(
      _powf(1.0f - tsn, _powf(2.0f, -hs_rng_c)),
      _powf(1.0f - tsn, _powf(2.0f, -hs_rng_m)),
      _powf(1.0f - tsn, _powf(2.0f, -hs_rng_y)));
    
    // limit C and Y strength
    hs_cmy *= make_float3(ha_cmy.x*ha_cmy.x, ha_cmy.y*ha_cmy.y, _powf(ha_cmy.z, 1.5f));
    float3 hsf = make_float3(hs_cmy.x*-hs_c, hs_cmy.y*hs_m, hs_cmy.z*hs_y);
    hsf = make_float3(hsf.z - hsf.y, hsf.x - hsf.z, hsf.y - hsf.x);
    rgb += hsf;
  }

  

  /***************************************************
    Value
  --------------------------------------------------*/
  if (vl_enable) {
    float vl_f = (vl_r*ha_rgb.x + 1.0f)*(vl_g*ha_rgb.y + 1.0f)*(vl_b*ha_rgb.z + 1.0f);
    vl_f *= (vl_c*ha_cmy.x + 1.0f)*(vl_m*ha_cmy.y + 1.0f)*(vl_y*ha_cmy.z + 1.0f);
    float vl_ts = vl_f > 1.0f ? 1.0f - ts_pt : ts_pt;
    float vl_lim = spowf(vl_f>1.0f ? (1.0f - vl_ts) : vl_ts, 1.0f - vl_rng)*(1.0f - spowf(mn, 1.0f/(_fmaxf(1e-6, 1.0f - vl_st))));
    vl_f = vl_f*vl_lim + 1.0f - vl_lim;
    vl_f = _fmaxf(0.0f, _fminf(2.0f, vl_f)); // protect for shadow grain
    rgb *= vl_f;
  }



  ts_pt_cmp = 1.0f - ts_pt_cmp;


  /***************************************************
    Mid-Range Purity 
  --------------------------------------------------*/
  if (ptm_enable) {
    // Mid Purity High
    float ptm_high_rng = 1.0f; // tonescale range
    float ptm_high_st0 = 0.5f; // sat strength (ptm_high_st is post-mix with tsn)
    float ptm_high_f = _powf(1.0f - ptm_high*_powf(rats_mx_div_mn, 1.0f/ptm_high_st0)*_powf(tsn, ptm_high_rng), 1.0f/_fmaxf(1e-3f, 1.0f - ptm_high_st));
    rgb = rgb*ptm_high_f + ((rgb.x + rgb.y + rgb.z)/3.0f)*(1.0f - ptm_high_f);

    // Mid Purity Low
    float ptm_mn = 1.0f - rats_mx_div_mn;
    float ptm_c = _powf(_fmaxf(0.0f, 1.0f - 1.2f*ptm_mn), 1.0f/ptm_low_st); // limit sat strength 
    float ptm_wt = ptm_mn < 1e-3f ? 1.0f : (ha_cmy_wide.x*0.25f + ha_cmy_wide.y*0.65f + ha_cmy_wide.z*0.1f)/0.9f/ptm_mn;
    float ptm_low_f = (1.0f + 2.0f*ptm_low*ptm_wt*ptm_c)*(1.0f - ts_pt) + ts_pt;
    ts_pt_cmp *= ptm_low_f;
  }


  // Purity Compression
  rgb = rgb*ts_pt_cmp + 1.0f - ts_pt_cmp;


  // Inverse Rendering Space
  sat_L = rgb.x*rs_w.x + rgb.y*rs_w.y + rgb.z*rs_w.z;
  rgb = (sat_L*rs_sa - rgb)/(rs_sa - 1.0f);
  

  // Convert to final display gamut
  float3 cwp_rgb = rgb;
  if (display_gamut==0) {
    if (cwp==1) cwp_rgb = vdot(matrix_p3_to_rec709_d60, rgb);
    if (cwp==2) cwp_rgb = vdot(matrix_p3_to_rec709_d55, rgb);
    if (cwp==3) cwp_rgb = vdot(matrix_p3_to_rec709_d50, rgb);
    rgb = vdot(matrix_p3_to_rec709_d65, rgb);
    if (cwp==0) cwp_rgb = rgb;
  }
  else if (display_gamut==1) {
    if (cwp==1) cwp_rgb = vdot(matrix_p3_to_p3_d60, rgb);
    if (cwp==2) cwp_rgb = vdot(matrix_p3_to_p3_d55, rgb);
    if (cwp==3) cwp_rgb = vdot(matrix_p3_to_p3_d50, rgb);
  }

  // Mix between Creative Whitepoint and D65 by tsn
  float cwp_f = _powf(tsn, 1.0f - cwp_rng);
  rgb = cwp_rgb*cwp_f + rgb*(1.0f - cwp_f);


  // Purity Softclip
  if (pt_softclip) {
    rgb = 1.0f - rgb;
    rgb.x = compress_powerp(rgb.x, 0.02f);
    rgb.y = compress_powerp(rgb.y, 0.05f);
    rgb.z = compress_powerp(rgb.z, 0.015f);
    rgb = 1.0f - rgb;
  }

  // Final tonescale scaling 
  tsn *= ts_m2;
  tsn = compress_toe_quadratic(tsn, tn_toe, 0);
  tsn *= ts_dsc;
  rgb *= tsn;

  // Clamp
  rgb = clampf3(rgb, 0.0f, 1.0f);

  // Rec.2020 (P3 Limited)
  if (display_gamut==2) {
    rgb = vdot(matrix_p3_to_rec2020, rgb);
  }

  // Apply inverse Display EOTF
  float eotf_p = 2.0f + eotf * 0.2f;
  if ((eotf > 0) && (eotf < 4)) {
    rgb = spowf3(rgb, 1.0f/eotf_p);
  } else if (eotf == 4) {
    rgb = eotf_pq(rgb, 1);
  } else if (eotf == 5) {
    rgb = eotf_hlg(rgb, 1);
  }
  
  return rgb;
}